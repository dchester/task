#!/usr/bin/env perl

our $VERSION = "4.00";

# DO NOT EDIT -- this is an auto generated file

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Task/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_BASE';
  package App::Task::Base;use Moo;use IO::CaptureOutput qw(capture_exec capture_exec_combined);use IO::Interactive qw(is_interactive);use Getopt::Long;use Term::ANSIColor;use App::Task::ContentTracker;use App::Task::Config;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through require_order));our$VERSION='4.00';my$instance;sub instance {return$instance if$instance;die __PACKAGE__ .' instance has not been built yet'}sub BUILD {my ($self,$args)=@_;if (my$message=App::Task::Config->configure($args->{config_file})){usage($message)}$instance=$self;GetOptions('help|h'=>sub {usage()},'verbose|v+'=>\($App::Task::Config::options{verbose}),)or usage()}sub run {my ($self)=@_;my$content_tracker=App::Task::ContentTracker->new;my$command_name=shift@ARGV;usage()if!$command_name;my$command=App::Task::Config->find_command($command_name);if (!$command){usage("Invalid command: $command_name")}my$command_instance=$command->{module}->new(content_tracker=>$content_tracker,);$command_instance->run}sub prompt {my ($self,%options)=@_;$self=instance()if!ref$self;print 'Enter ' .join(', ',map {"'$_' to $options{$_}"}grep {!/default/}keys%options).', anything else to exit: ';chomp(my$response=<STDIN>);if (defined$options{lc$response}){return$options{lc$response}}elsif (defined$options{default}){return$options{default}}else {print "Exiting...\n";exit}}sub system_call {my ($self,$command,%options)=@_;$self=ref$self ? $self : instance();$command=[$command ]if!ref$command;my$command_text=join(' ',@$command);if (App::Task::Config->get_option('verbose')&& App::Task::Config->get_option('verbose')>= 1 || $options{verbose}){printf("\r%s\r",' ' x 80)if is_interactive();print "* $command_text\n"}my ($stdout,$stderr);if ($options{combine}){($stdout)=capture_exec_combined(@$command)}else {($stdout,$stderr)=capture_exec(@$command)}my$exit_status=$? & 127 ? $? & 127 : $? >> 8;my$output='';if ($stdout){chomp(my$stdout_copy=$stdout);$stdout_copy =~ s/(?!\A)^/** /gims;$output .= "** stdout: '$stdout_copy'\n"}if ($stderr){chomp(my$stderr_copy=$stderr);$stderr_copy =~ s/(?!\A)^/** /gims;$output .= "** stderr: '$stderr_copy'\n"}if (!defined$options{ignore_exit_status}and $exit_status){$self->highlighted_die("Command failed: $command_text\n$output\n")}if (App::Task::Config->get_option('verbose')&& App::Task::Config->get_option('verbose')>= 2){print$output}return ($stdout,$stderr,$exit_status)}sub highlighted_die {my ($self,$message)=@_;$message =~ s/(\n?)\z/color('reset') . $1/e;die color('red').$message}sub environments {my ($class)=@_;return App::Task::Config->config->{environments}}sub usage {my ($message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";for my$command_name (App::Task::Config->command_list){printf "    %-12s %s\n",$command_name,App::Task::Config->find_command($command_name)->{description}}print "\nUse 'task <subcommand> --help' for more information\n";exit 1}no Moo;1;
  Usage: task <subcommand>
  
  task is a release management tool for git designed to aid multi-user
  development in tiny chunks (task branches). It supports
  multiple environments and can build de facto releases (defined by whatever is
  on a given branch) or versioned releases
  
  Available subcommands are:
  END_USAGE
APP_TASK_BASE

$fatpacked{"App/Task/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND';
  package App::Task::Command;use Moo::Role;use Types::Standard qw(ArrayRef HashRef InstanceOf);use Cwd qw(getcwd);use Getopt::Long;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through permute));has 'environment'=>(is=>'ro',isa=>HashRef,reader=>'get_environment');has 'content_tracker'=>(is=>'ro',required=>1,isa=>InstanceOf['App::Task::ContentTracker'],reader=>'content_tracker');has 'task_branch'=>(is=>'rw');has 'original_dir'=>(is=>'ro',default=>sub {getcwd()},reader=>'get_original_dir');has 'allow_branch_switch'=>(is=>'rw',default=>0);has 'deployment_branch'=>(is=>'rw',reader=>'get_deployment_branch',writer=>'set_deployment_branch');requires 'run';requires 'usage';around 'run'=>sub {my ($next,$self,%options)=@_;my$original_branch=$self->content_tracker->get_current_branch;$self->content_tracker->update_remotes;my@returned_values;eval {@returned_values=$next->($self)};my$error;if ($@){$error=$@}$self->return_to_original_dir;my$current_branch=$self->content_tracker->get_current_branch;if ($current_branch ne $original_branch and!$self->allow_branch_switch){App::Task::Base->system_call("git checkout '$original_branch'")}die$error if$error;return (@returned_values)};sub return_to_original_dir {my ($self)=@_;my$current_dir=getcwd;my$original_dir=$self->get_original_dir;if ($original_dir ne $current_dir){chdir$self->get_original_dir or die "Couldn't change back to $original_dir from $current_dir"}}sub set_environment {my ($self,$env)=@_;if ($env){$self->{environment}=App::Task::Base->environments->{$env}or die "Invalid destination environment: $env"}else {my$destination_env=shift@ARGV;$self->usage("error: No environment specified")if!defined$destination_env;$self->{environment}=App::Task::Base->environments->{$destination_env};if (!defined$self->{environment}){$self->usage("error: '$destination_env' is not a valid environment\nvalid environments are: " .join(', ',sort keys %{App::Task::Base->environments}))}}}sub env {my ($self)=@_;return$self->{environment}}sub add_task {my ($self,$branch_name)=@_;if (my ($valid_branch)=sort$self->content_tracker->get_branches_by_prefix($branch_name)){$self->task_branch($valid_branch);return 1}return 0}sub resolve_file {my ($self,$path)=@_;my$relative_to_root=`git rev-parse --show-cdup`;chomp$relative_to_root;if (-e $path){if ($relative_to_root){return abs2rel(abs_path(rel2abs$path),$self->content_tracker->get_repository_root)}else {return$path}}return$path if -e "$relative_to_root$path";die "Couldn't find file: $path"}sub parse_options {my ($self,%options)=@_;$options{'verbose|v+'}=\($App::Task::Config::options{verbose});GetOptions(%options)or $self->usage};no Moo::Role;no Types::Standard;1;
APP_TASK_COMMAND

$fatpacked{"App/Task/Command/Cleanup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_CLEANUP';
  package App::Task::Command::Cleanup;use Moo;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(cleanup=>'Cleanup branches that have been deployed or abandoned');sub BUILD {my ($self,$args)=@_;my$deployed_to_env='prod';my$days=7;$self->parse_options('help|h'=>sub {$self->usage},'delete|d'=>sub {App::Task::Config->set_option('delete-task-branches'=>1)},'days=i'=>\$days,'deployed-to=s'=>\$deployed_to_env,);die "Invalid env '$deployed_to_env'" if!defined App::Task::Base->environments->{$deployed_to_env};App::Task::Config->set_option('deployed-to'=>$deployed_to_env);App::Task::Config->set_option('days-since-last-commit'=>$days);for my$arg (@ARGV){if (!$self->add_task($arg)){print "Unknown option: $arg\n"}}}sub run {my ($self)=@_;$self->content_tracker->update_remotes;my ($local_branches)=App::Task::Base->system_call("git branch");my ($current_branch)=$local_branches =~ /^\* ([^\n]+)/ims;LOCAL_BRANCH: for my$raw_branch (split /\n/,$local_branches){my ($branch_name)=$raw_branch =~ /^\*?[ \t]*\b(.*)/ims;next LOCAL_BRANCH if!$branch_name;next LOCAL_BRANCH if$self->task_branch !~ /^\Q$branch_name/;my ($deployed_envs)=$self->content_tracker->get_deployed_envs($branch_name);my$target_env=App::Task::Config->get_option('deployed-to');if (defined$deployed_envs->{integration}and defined$deployed_envs->{$target_env}){chomp(my ($last_commit_timestamp)=App::Task::Base->system_call("git log -1 --pretty=format:'%ct' '$target_env/$branch_name'",ignore_exit_status=>1));if (!$last_commit_timestamp){chomp(my ($sha1)=App::Task::Base->system_call("git rev-parse $branch_name"));chomp(($last_commit_timestamp)=App::Task::Base->system_call("git log -1 --pretty=format:'%ct' '$sha1'"))}my$actual_days_since_last_commit=int((time()- $last_commit_timestamp)/ 86400);if ($actual_days_since_last_commit >= App::Task::Config->get_option('days-since-last-commit')){print "Branch '$branch_name' has existed on $target_env for $actual_days_since_last_commit days and can be deleted\n";if (App::Task::Config->get_option('delete-task-branches')){system("git branch -D '$branch_name'")}}}}}sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task cleanup [-hd] <branch_name>
  
  Show (and delete) task branches that have been deployed to production or another environment
  
  Options:
  
      -h, --help                   Show a brief help message and exit
      -n, --noconfirm  Don't show a confirmation message before doing the deploy
      -d, --delete                 Delete the branches that exist on the target
                                   environment
      --deployed-to=<environment>  Sets the target environment for which task
                                   branches must have been deployed to.
                                   Defaults to what your mainline branch is set to
      --days=<number>              Make sure the task branches have existed on the
                                   target environment for at least this many days
  
  Examples:
  
      task cleanup
  
  Show local branches whose tips have existed on prod for at least 7 days
  
      task cleanup -d
  
  Delete local branches whose tips have existed on prod for at least 7 days
  END_USAGE
APP_TASK_COMMAND_CLEANUP

$fatpacked{"App/Task/Command/Deploy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_DEPLOY';
  package App::Task::Command::Deploy;use Moo;use Cwd qw(getcwd);use Term::ANSIColor;use App::Task::Config;use App::Task::Hooks;with 'App::Task::Command';App::Task::Config->register_command(deploy=>'Deploy a task branch to a given environment (and all its dependent envs too)');sub highlighted_die {my ($message)=@_;$message =~ s/(\n?)\z/color('reset') . $1/e;die color('red').$message}sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},'noconfirm|n'=>sub {App::Task::Config->set_option('noconfirm'=>1)},'again'=>sub {App::Task::Config->set_option('redeploy'=>1)},);$self->set_environment($args->{destination_environment});my$branch_name=$self->env->{branch_name};$self->content_tracker->update_remotes;my ($branch_tip)=App::Task::Base->system_call("git rev-parse 'origin/$branch_name'");chomp$branch_tip;if (scalar@ARGV and!$self->task_branch){my@files;while (my$arg=pop@ARGV){if ($arg =~ /-deploy\d+$/ && $self->add_task($arg)){$self->set_deployment_branch($arg)}elsif (!$self->add_task($arg)){my$file=$self->resolve_file($arg);push@files,$file}}if (@files){my$deployment_branch=$self->content_tracker->add_files_to_new_deployment_branch($self->task_branch,\@files);$self->set_deployment_branch($deployment_branch)}}}sub run {my ($self)=@_;my$current_dir=getcwd;my$env_name=$self->env->{name};my@branches;TASK: my$task_branch=$self->task_branch;my$ready=App::Task::Command::Ready->new(destination_environment=>$self->env->{name},content_tracker=>$self->content_tracker,deployment_branch=>$self->get_deployment_branch,);$ready->add_task($task_branch);my$branch_name=$ready->run;push(@branches,$branch_name);my@unpushed_files;my@deployment_branches;my$target_branch_name=$self->env->{branch_name};$task_branch=$self->task_branch;my$current_branch_name=$self->content_tracker->get_branch_name($task_branch);my$deployment_branch_name=$self->get_deployment_branch || $current_branch_name;my@files=$self->content_tracker->get_changed_files($task_branch,"origin/$target_branch_name",branch_name=>$deployment_branch_name);push(@unpushed_files,@files);if (App::Task::Config->get_option('redeploy')){my ($file_list,$err,$exit_status)=App::Task::Base->system_call("git diff --name-only origin/master...$env_name/$deployment_branch_name",ignore_exit_status=>1);if (!$exit_status){chomp$file_list;my@files=map {s/^\s*|\s*$//ms;$_}split(/\n/,$file_list);push(@unpushed_files,@files)}}push@deployment_branches,$deployment_branch_name;my$changed_file_count=scalar@unpushed_files;if ($changed_file_count){print "$changed_file_count " .($changed_file_count > 1 ? 'files' : 'file')." to deploy to $env_name\n"}else {print "No changed files to deploy to $env_name";print "\n\n";return}my$remote_files=join(' ',map {"'$_'"}@unpushed_files);my$original_branch=$self->content_tracker->get_current_branch;my$temp_branch_exists=0;eval {my%merged_branches;my$temp_branch_name="temp_deploy_${env_name}";App::Task::Base->system_call("git checkout --track -b '$temp_branch_name' origin/$target_branch_name");$temp_branch_exists=1;for my$deployment_branch_name (@deployment_branches){if ($env_name eq 'integration'){$self->content_tracker->safe_merge($deployment_branch_name,$env_name,'integration','','deploy')}else {$self->content_tracker->safe_merge("origin/$env_name-ready/$deployment_branch_name",$env_name,$temp_branch_name,'--ff-only','deploy')}$merged_branches{$deployment_branch_name}=1}my ($diffstat)=App::Task::Base->system_call("git diff --stat=120,100 'origin/$target_branch_name'..'$temp_branch_name'");print "Deploying the following changes to $env_name:\n$diffstat\n";if (!App::Task::Config->get_option('noconfirm')){print "Enter 'y' to continue, anything else to exit: ";chomp(my$response=<STDIN>);if (lc$response ne 'y'){$self->return_to_original_dir;App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D 'temp_deploy_$env_name'");exit}}App::Task::Base->system_call("git pull origin '$target_branch_name'");App::Task::Base->system_call("git push origin 'temp_deploy_$env_name:$target_branch_name'");print "Updated git $env_name branch\n";App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -d 'temp_deploy_$env_name'");$temp_branch_exists=0;my$current_dir=getcwd;my%deployed_branches;for my$branch_name (@branches){$deployed_branches{$branch_name}++}chomp(my ($deploy_sha)=App::Task::Base->system_call("git rev-parse HEAD"));my$hooks_ok=App::Task::Hooks->run_hooks($self,'post_deploy',{TASK_DEPLOY_ENVIRONMENT=>$env_name,TASK_DEPLOY_SHA=>$deploy_sha,});die "Failed to run hooks" unless$hooks_ok;if ($self->env->{branch_name}eq App::Task::Config->config->{mainline_branch}and $self->env->{dependent_environment}){App::Task::Config->set_option('needs-update'=>1);$self->content_tracker->update_remotes;my$dependent_env_name=$self->env->{dependent_environment};$self->merge_back_to_dependent_environments($env_name,$dependent_env_name)}chdir$current_dir or highlighted_die "Couldn't chdir to: $current_dir"};if ($@){$self->return_to_original_dir;App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D 'temp_deploy_$env_name'")if$temp_branch_exists;die $@}else {print color 'green';print "finished deploying to $env_name\n\n";print color 'reset'}}sub merge_back_to_dependent_environments {my ($self,$top_level_env,$dependent_env_name)=@_;my$top_level_env_branch=App::Task::Base->environments->{$top_level_env}{branch_name};my$dependent_env_branch=App::Task::Base->environments->{$dependent_env_name}{branch_name};my$temp_branch_name="temp_merge_${top_level_env}_back_to_${dependent_env_name}";App::Task::Base->system_call("git checkout -b '$temp_branch_name' origin/$dependent_env_branch");$self->content_tracker->safe_merge("origin/$top_level_env_branch",$dependent_env_name,"origin/$dependent_env_branch",'','');App::Task::Base->system_call("git push origin '$temp_branch_name:$dependent_env_branch'");App::Task::Base->system_call("git checkout master");App::Task::Base->system_call("git branch -D '$temp_branch_name'");print "Merged changes from $top_level_env back to $dependent_env_name\n";if (my$next_dependent_env=App::Task::Base->environments->{$dependent_env_name}{dependent_environment}){$self->merge_back_to_dependent_environments($top_level_env,$next_dependent_env)}else {return}}no Moo;sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task deploy [-hn] [--again] environment <branch_name>
  
  Merge and deploy task branches
  
  Options:
  
      -h, --help       Show a brief help message and exit
      -n, --noconfirm  Don't show a confirmation message before doing the deploy
      --again          Ignore if a branch has already been deployed to an
                       environment and re-deploy again anyway. Basically this
                       will rerun your hooks for this environment without merging
                       anything
  END_USAGE
APP_TASK_COMMAND_DEPLOY

$fatpacked{"App/Task/Command/Ready.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_READY';
  package App::Task::Command::Ready;use Moo;use Term::ANSIColor;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(ready=>'Pre-merge a task branch with an environment branch for later deployment');sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},);$self->set_environment($args->{destination_environment});if (scalar@ARGV and!$self->task_branch){my@files;while (my$arg=pop@ARGV){if ($arg =~ /-deploy\d+$/ && $self->add_task($arg)){$self->set_deployment_branch($arg)}elsif (!$self->add_task($arg)){my$file=$self->resolve_file($arg);push@files,$file}}if (@files){my$deployment_branch=$self->content_tracker->add_files_to_new_deployment_branch($self->task_branch,\@files);$self->set_deployment_branch($deployment_branch)}}}sub run {my ($self)=@_;my$is_final_command=(caller(4))[0]=~ /^App::Task::Base$/ ? 1 : 0;my (@changed_files,@ready_tasks,$diff_stat);my$env_name=$self->env->{name};my ($remotes)=App::Task::Base->system_call("git remote");my%remotes=map {$_=>1}split(/\n/,$remotes);if (!exists$remotes{'origin'}){die color('red')."You don't have a remote set up. Please re-clone the repository" .color('reset')}my$original_branch=$self->content_tracker->get_current_branch;my$merge_commit_id;my$repository_root=$self->content_tracker->get_repository_root;my$task_branch=$self->task_branch;my$branch_name=$self->content_tracker->get_branch_name($task_branch);my$deployment_branch_name=$self->get_deployment_branch || $branch_name;my$deployed_envs=$self->content_tracker->get_deployed_envs($deployment_branch_name);my$dependent_env=$self->env->{dependent_environment};if (defined$dependent_env and!exists$deployed_envs->{$dependent_env}){my$dependent_deploy=App::Task::Command::Deploy->new(destination_environment=>$self->env->{dependent_environment},content_tracker=>$self->content_tracker,deployment_branch=>$self->get_deployment_branch,);$dependent_deploy->add_task($task_branch);$dependent_deploy->run}App::Task::Base->system_call("git checkout $original_branch");my$remote_task_branch_name='';if ($env_name eq 'integration'){($remote_task_branch_name)=map {/^\s*(origin\/$deployment_branch_name)$/ims ? $1 : ()}`git branch -r`}else {($remote_task_branch_name)=map {/^\s*(origin\/$env_name-ready\/$deployment_branch_name)$/ims ? $1 : ()}`git branch -r`}my$temp_branch_name="temp_${env_name}_merge_$deployment_branch_name";my$allow_ready=$self->env->{allow_ready};eval {my$diff_branch=$temp_branch_name;my$env_branch_name=App::Task::Base->environments->{$env_name}{branch_name};if ($remote_task_branch_name){App::Task::Base->system_call("git checkout -b $temp_branch_name $remote_task_branch_name")}elsif ($allow_ready){App::Task::Base->system_call("git checkout -b $temp_branch_name origin/$env_branch_name")}else {App::Task::Base->system_call("git checkout -b $temp_branch_name $deployment_branch_name");$diff_branch="origin/$env_branch_name"}@changed_files=$self->content_tracker->get_changed_files($task_branch,$diff_branch,branch_name=>$deployment_branch_name);if ($is_final_command){($diff_stat)=App::Task::Base->system_call("git diff -p --stat --color '$diff_branch'...'$deployment_branch_name'",ignore_exit_status=>1)}$self->content_tracker->safe_merge($deployment_branch_name,$env_name,$temp_branch_name,'--no-ff --log',$remote_task_branch_name ? 're-ready' : 'ready');if ($allow_ready){$self->content_tracker->safe_merge("origin/$env_branch_name",$env_name,$temp_branch_name,'--no-ff --log',$remote_task_branch_name ? 're-ready' : 'ready')}chomp(($merge_commit_id)=App::Task::Base->system_call("git rev-parse '$temp_branch_name'"));push(@ready_tasks,$task_branch);if ($env_name eq 'integration'){App::Task::Base->system_call("git push origin 'HEAD:$deployment_branch_name'")}else {App::Task::Base->system_call("git push origin 'HEAD:$env_name-ready/$deployment_branch_name'")}App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D $temp_branch_name")};if ($@){App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D $temp_branch_name",ignore_exit_status=>1);App::Task::Base->instance->highlighted_die($@)}my$changed_file_count=scalar@changed_files;if ($changed_file_count){print "\n$changed_file_count " .($changed_file_count > 1 ? 'files' : 'file')." ready for $env_name\n"}else {print "\nNo changed files to set as ready for $env_name\n";return}print join('',map {"\t$deployment_branch_name\t$_\n"}@changed_files);print "\n";print "ready for $env_name - commit id: $merge_commit_id\n";my$github_url=App::Task::Config->config->{github_url};my$env_branch_name=App::Task::Base->environments->{$env_name}{branch_name};if ($github_url){print "View the full diff here: $github_url/compare/$env_branch_name...$merge_commit_id\n"}return$deployment_branch_name}sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task ready [-hn] environment <branch_name>
  
  Pre-merge task branches and set them as ready for deployment without actually deploying them
  
  Options:
  
      -h, --help     Show a brief help message and exit
  END_USAGE
APP_TASK_COMMAND_READY

$fatpacked{"App/Task/Command/Start.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_START';
  package App::Task::Command::Start;use Moo;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(start=>'Start work on a new or existing task branch');sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},);my$arg=shift@ARGV;if ($arg){$self->task_branch($arg)}$self->{allow_branch_switch}=1;$self->usage("No feature branch name specified to start work on")if!$self->task_branch}sub run {my ($self)=@_;$self->content_tracker->update_remotes;if (my$branch=$self->task_branch){$self->create_task_branch($branch)}}sub create_task_branch {my ($self,$branch)=@_;my$branch_name=$self->content_tracker->get_branch_name($branch);$self->content_tracker->_create_branch($branch_name)}sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task start [-h] <branch_name>
  
  Properly starts a task branch from your mainline branch
  
  Options:
  
      -h, --help     Show a brief help message and exit
  
  Examples:
  
      task start feature/docs
  
      creates a branch feature/docs from origin/master
      or checks it out if someone else already created it
  END_USAGE
APP_TASK_COMMAND_START

$fatpacked{"App/Task/Command/Status.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_STATUS';
  package App::Task::Command::Status;use Moo;use Types::Standard qw(HashRef ArrayRef);use Term::ANSIColor;use IO::Interactive qw(is_interactive);use App::Task::Config;with 'App::Task::Command';has 'envs'=>(is=>'ro',isa=>HashRef,default=>sub {{}});has 'visited_commits'=>(is=>'rw',isa=>HashRef,default=>sub {return {}});has 'args'=>(is=>'rw',isa=>HashRef,default=>sub {return {}});has 'ordered_envs'=>(is=>'lazy',isa=>ArrayRef);has 'indent'=>(is=>'rw',default=>sub {0});has 'columns'=>(is=>'lazy');$|=1;App::Task::Config->register_command(status=>'View the status of a task branch');sub _build_columns {my$self=shift;return unless is_interactive();my ($wchar)=$ENV{COLUMNS}|| 80;return$wchar - 2};sub BUILD {my ($self,$args)=@_;$self->args->{color}=1 if is_interactive();$self->parse_options('help|h'=>sub {$self->usage},'diff|p!'=>\$self->args->{diff},'diff-options=s'=>\$self->args->{diff_options},'log|l!'=>\$self->args->{log},'log-options=s'=>\$self->args->{log_options},'color|colour|c!'=>\$self->args->{color},'all-commits!'=>\$self->args->{all_commits},'name-only!'=>\$self->args->{name_only},);my@new_argv;if (!scalar@ARGV){my$current_branch=$self->content_tracker->get_current_branch;$self->add_task($current_branch)}for my$arg (@ARGV){if (!$self->add_task($arg)){push(@new_argv,$arg)}}if (scalar@new_argv){$self->abort("Unrecognized option: '@new_argv'")}$self->usage if!$self->task_branch}sub _build_ordered_envs {my$self=shift;my$environments=App::Task::Base->environments;my ($current_top_level_env)=map {$environments->{$_}{branch_name}eq App::Task::Config->config->{mainline_branch}? $_ : ()}keys %$environments;my@ordered_envs;while ($current_top_level_env && defined$environments->{$current_top_level_env}){push(@ordered_envs,$current_top_level_env);push(@ordered_envs,"ready for $current_top_level_env")if$environments->{$current_top_level_env}{allow_ready};$current_top_level_env=$environments->{$current_top_level_env}{dependent_environment}|| undef}push(@ordered_envs,'Un-merged changes');return \@ordered_envs}sub increase_indent {my$self=shift;$self->indent($self->indent()+ 4)}sub decrease_indent {my$self=shift;$self->indent($self->indent()- 4)}sub print_indented {my ($self,$text)=@_;print " " x $self->indent(),$text,"\n"}sub get_status {my ($self,$task_branch_name)=@_;chomp(my ($merged_to_master)=App::Task::Base->system_call("git rev-list -n 1 origin/master ^$task_branch_name"));my$master_before_merge=$merged_to_master ? "$merged_to_master^" : "origin/master";chomp(my ($merge_base)=App::Task::Base->system_call("git merge-base $master_before_merge $task_branch_name"));my$start=$merge_base;my$definitive_branch=$task_branch_name;my@branch_commits=$self->get_rev_list($start,$definitive_branch);unless (@branch_commits){$definitive_branch="origin/$task_branch_name";@branch_commits=$self->get_rev_list($start,$definitive_branch)}my%env_commits=$self->get_env_commits(start=>$start,branch=>$task_branch_name,branch_commits=>\@branch_commits,);return (env_commits=>\%env_commits,branch_commits=>\@branch_commits,)}sub get_env_commits {my ($self,%args)=@_;die "start not specified" if!$args{start};die "branch not specified" if!$args{branch};my$branch=$args{branch};my@envs=@{$self->ordered_envs};my@branch_rev_list=$args{branch_commits}? @{$args{branch_commits}}: $self->get_rev_list($args{start},$branch);$self->die_no_commits($branch)unless (@branch_rev_list);my%branch_rev_hash=map {$_=>1}@branch_rev_list;my%env_commits;my$prev_env;for my$env (@envs){my ($remote_branch,$repo)=$self->get_remote_branch_for_env($env,$branch);$remote_branch=$repo ? "$repo/$remote_branch" : $remote_branch;my$len=print_disappearing(msg=>"Fetching rev-list for '$env'...");my%remote_rev_list=map {exists$branch_rev_hash{$_}? ($_=>1): ()}$self->get_rev_list($args{start},$remote_branch);print_disappearing(len=>$len);$env_commits{$env}={abs_commits=>{list=>[],hash=>{}},rel_commits=>{list=>[],hash=>{}},};for my$commit (@branch_rev_list){if ($remote_rev_list{$commit}){push @{$env_commits{$env}->{abs_commits}->{list}},$commit;$env_commits{$env}->{abs_commits}->{hash}->{$commit}=1}}$env_commits{$env}->{branch_start_name}=$args{start};chomp(my ($start_ref)=App::Task::Base->system_call("git show-ref $args{start}",ignore_exit_status=>1,));$start_ref ||=$args{start};$env_commits{$env}->{branch_start_ref}=(split(/\s+/,$start_ref))[0];$env_commits{$env}->{branch_tip}=$env_commits{$env}->{abs_commits}->{list}->[0]|| '';if ($prev_env && $env_commits{$env}->{branch_tip}eq $env_commits{$prev_env}->{branch_tip}){$env_commits{$env}->{same_as_prev_env}=1}for my$commit (@{$env_commits{$env}->{abs_commits}->{list}}){my$prev_branch_tip=$prev_env && $env_commits{$prev_env}->{branch_tip};if ($prev_env && $prev_branch_tip && $commit eq $prev_branch_tip){$prev_env=$env;last}push @{$env_commits{$env}->{rel_commits}->{list}},$commit;$env_commits{$env}->{rel_commits}->{hash}->{$commit}=1}$prev_env=$env}return%env_commits}sub die_no_commits {my$self=shift;my ($branch)=@_;chomp(my ($stdout)=App::Task::Base->system_call("git branch -a"));my@all_branches=grep {s/^..//}split("\n",$stdout);my@branches=grep {m{(\w+/)*$branch}}@all_branches;if (@branches){warn$self->print_color(['red'],"The branch: '$branch' exists on the repositories below, but has no commits."),"\n";$self->increase_indent;$self->print_indented($_)for@branches;$self->decrease_indent;die "\n"}else {die$self->print_color(['red'],"The branch: '$branch' does not exist locally, or on any remote."),"\n"}}sub print_disappearing {my (%args)=@_;return unless is_interactive();if ($args{msg}){print$args{msg};return length$args{msg}}elsif ($args{len}){my$spaces=(' ')x $args{len};print "\r$spaces\r"}}sub get_branch_range {my ($start,$end)=@_;return$end ? "$start..$end" : $start}sub get_rev_list {my$self=shift;my ($start,$end)=@_;my$refspec=get_branch_range($start,$end);my@cmd_rev_list=('git rev-list --no-merges',$refspec);my$cmd=join ' ',@cmd_rev_list;my ($stdout,$stderr,$exit_status)=App::Task::Base->system_call($cmd,ignore_exit_status=>1,);my@rev_list=split "\n",$stdout;return@rev_list}sub get_remote_branch_for_env {my ($self,$env,$task_branch_name)=@_;my ($target_branch_name,$remote);my$final_env=$env;if ($env =~ /^ready for (\w+)/){$target_branch_name=$task_branch_name;$final_env=$1;if ($final_env eq 'integration'){$remote='origin'}else {$remote="origin/$final_env-ready"}}elsif ($env eq 'Un-merged changes'){$target_branch_name=$task_branch_name;$remote=''}else {$target_branch_name=App::Task::Base->environments->{$final_env}{branch_name};$remote="origin"}if ($target_branch_name eq 'master'){$target_branch_name=App::Task::Base->environments->{$final_env}{branch_name}}return ($target_branch_name,$remote)}sub print_git_command {my$self=shift;my ($cmd)=@_;my ($output,$error,$exit_status)=App::Task::Base->system_call($cmd);my@lines=split(/\n/,$output);if ($cmd =~ /--stat\b/){if (grep {$_ =~ m{ \.\.\./}}@lines){push@lines,$self->print_color(['black']," (specify --name-only to see full file names)")}}$self->print_indented($_)for@lines;print "\n";return [$output,$error,$exit_status]}sub get_indented_screen_width {my$self=shift;return unless$self->columns;return$self->columns - $self->indent}sub make_git_stat_cmd {my$self=shift;my$w=$self->get_indented_screen_width;return '--stat' unless$w;return "--stat=$w,$w"}sub print_color {my$self=shift;my ($color_list,$string)=@_;if ($self->args->{color}){return colored($color_list,$string)}else {return$string}}sub run {my ($self)=@_;if (my$branch=$self->task_branch){my$task_branch_name=$self->content_tracker->get_branch_name($branch);my@deployment_branches=$self->content_tracker->get_all_deployment_branches($branch);for my$branch_name ($task_branch_name,@deployment_branches){my%status=$self->get_status($branch_name);$self->print_status_info(branch=>$branch_name,status=>\%status,)}}}sub print_status_info {my$self=shift;my%args=@_;my$task_branch_name=$args{branch};die "branch not specified" if!$args{branch};die "status not specified" if!$args{status};my$git_args=$self->args->{color}? '--color' : '';$self->print_indented($self->print_color(['bold'],"Deployment status for $task_branch_name:\n"));$self->increase_indent;my@envs=@{$self->ordered_envs};my$prev_env;for my$env (@envs){my%env_commits=%{$args{status}->{env_commits}->{$env}};my$commit_key='rel_commits';my@commits=@{$env_commits{$commit_key}->{list}|| []};if (!scalar@commits || $env_commits{same_as_prev_env}){$prev_env=$env;next}my$commit_last=$env_commits{branch_tip};my$commit_first;if ($prev_env && $commit_key eq 'rel_commits'){$commit_first=$args{status}{env_commits}{$prev_env}{branch_tip}}$commit_first ||=$env_commits{branch_start_ref};my$commit_range="$commit_first..$commit_last";$self->print_env_label($env);$self->increase_indent;if ($self->args->{log}){my@log_args=('--no-merges');push@log_args,$self->make_git_stat_cmd();push@log_args,'-p' if$self->args->{diff};push@log_args,'--name-only' if$self->args->{name_only};$self->print_git_command(sprintf("git log $git_args %s %s %s",defined$self->args->{log_options}? $self->args->{log_options}: '',join(' ',@log_args),$commit_range))}else {my$l=$self->print_color(['blue'],"Branch tip:  ");my$c=$self->print_color(['yellow'],$commit_last);$self->print_indented("$l $c");my$short_range=$commit_first eq $commit_last ? substr($commit_first,0,7): substr($commit_first,0,7).'..' .substr($commit_last,0,7);$self->print_indented(sprintf("%s %s (%d commit%s)",$self->print_color(['blue'],"Commit range:"),$self->print_color(['yellow'],"$short_range"),scalar@commits,scalar@commits==1 ? '' : 's',));if ($self->args->{all_commits}){$self->print_indented($self->print_color(['blue'],"All commits:"));$self->increase_indent;for my$commit (@commits){$self->print_indented($self->print_color(['yellow'],$commit))}$self->decrease_indent}print "\n";my@diff_args;push@diff_args,'--name-only' if$self->args->{name_only};push@diff_args,$self->make_git_stat_cmd();push@diff_args,sprintf('-p %s',(defined$self->args->{diff_options}? $self->args->{diff_options}: ''))if$self->args->{diff};$self->print_git_command(sprintf("git diff $git_args %s %s",join(' ',@diff_args),$commit_range,))}$self->decrease_indent;$prev_env=$env}$self->decrease_indent}sub print_env_label {my$self=shift;my ($env)=@_;my$env_label="$env" ;$self->print_indented($self->print_color(['bold green'],"$env_label:"));if ($self->args->{log}|| $self->args->{diff}){$self->print_indented($self->print_color(['bold green'],'-' x ($self->get_indented_screen_width || 80)))}}sub abort {my ($self,$message)=@_;print color 'red';print "$message\n";print color 'reset';exit}no Moo;no Types::Standard;sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task status [-h] <branch_name>
  
  Get info about which environments files for a task have been pushed to. Checks
  the status of the current task branch if none is specified.
  
  The most current version of the file (on HEAD) always shows up in bold.
  
  Options:
  
      -h, --help               Show a brief help message and exit
      --all-commits            Print a list of commits affected for each
                               environment, rather than just the commit range. This
                               gives a complete list of commits, without the
                               verbosity of --log.
      -c, --color, --colour    Enable colored output. On by default. Off when the
                               terminal isn't interactive, but can be forced by
                               manually setting --color.
      --diff-options <options> Specifies extra options to pass to `git diff` when
                               -p or --diff are used.
      -l, --log                Print `git log` information for each environment.
                               Can be used with --stat and -p or --diff to print
                               stat and diff information for each log entry.
      --log-options <options>  Specifies extra options to pass to `git log` when
                               --log is used.
      --name-only              Print a list of files affected for each environment,
                               without the verbosity of --stat. Can also be used if
                               the files affected printed by --stat are
                               abbreviated, since --name-only will not abbreviate
                               file names.
      -p, --diff               Print `git diff` information for each environment.
                               This will show diffs for entire environments, or
                               per log entry if used with --log.
  END_USAGE
APP_TASK_COMMAND_STATUS

$fatpacked{"App/Task/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_CONFIG';
  package App::Task::Config;use strict;use warnings;use YAML qw(LoadFile);my (%commands,%config_data);our%options;sub register_command {my ($module,$name,$description)=@_;if ($module eq __PACKAGE__){($module)=caller}$commands{$name}={description=>$description,module=>$module,}}sub command_list {return sort keys%commands}sub find_command {my ($package,$name)=@_;return$commands{$name}}sub get_option {my ($package,$option_name)=@_;return$options{$option_name}}sub set_option {my ($package,$option_name,$value)=@_;$options{$option_name}=$value}sub configure {my ($package,$config_file)=@_;undef%config_data;my ($relative_to_root)=`git rev-parse --show-cdup`;chomp$relative_to_root;if (!$config_file){$config_file=($relative_to_root ? "$relative_to_root/" : '').'deployment.yaml'}if (-e $config_file && -r $config_file){my$repo_config=LoadFile$config_file or die "Couldn't load config file '$config_file";$config_data{environments}=$repo_config->{environments};$config_data{mainline_branch}=$repo_config->{mainline_branch}|| 'master';$config_data{github_url}=$repo_config->{github_url};$config_data{hooks}=$repo_config->{hooks}}else {return "Can't read config file: $config_file"}$config_data{repo_root}=$relative_to_root || ".";for my$env (keys %{$config_data{environments}}){$config_data{environments}{$env}{name}=$env}return}sub config {return \%config_data}1;
APP_TASK_CONFIG

$fatpacked{"App/Task/ContentTracker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_CONTENTTRACKER';
  package App::Task::ContentTracker;use Moo;use File::Spec::Functions qw(rel2abs abs2rel);use Cwd qw(getcwd);use Term::ANSIColor;use IO::Interactive qw(is_interactive);has 'current_branch'=>(is=>'rw',lazy=>1,builder=>'_build_current_branch',clearer=>'_clear_current_branch',);has 'all_branches'=>(is=>'ro',lazy=>1,builder=>'_build_all_branches',clearer=>'_clear_all_branches',);no Moo;sub get_repository_root {my ($abs_top_level_dir)=App::Task::Base->system_call("git rev-parse --show-toplevel");chomp$abs_top_level_dir;return$abs_top_level_dir}sub create_deployment_branch {my ($self,$branch)=@_;my$task_branch_name=$self->get_branch_name($branch);my$deployment_branch_name=$self->get_next_deployment_branch_name($branch);my$mainline_branch=App::Task::Config->config->{mainline_branch};my ($merge_commit)=App::Task::Base->system_call("git merge-base $task_branch_name $mainline_branch",ignore_exit_status=>1);$self->_create_branch($deployment_branch_name,$merge_commit);return$deployment_branch_name}sub _create_branch {my ($self,$branch_name,$start_ref)=@_;my$mainline_branch=App::Task::Config->config->{mainline_branch};my@branches=@{$self->all_branches};if (!$start_ref){if (scalar grep {/^remotes\/origin\/$mainline_branch/ims}@branches){$start_ref="origin/$mainline_branch"}else {$start_ref=$mainline_branch}}my$original_branch=$self->get_current_branch;my$current_dir=getcwd;if (scalar grep {/^\Q$branch_name/i}@branches){my ($output)=App::Task::Base->system_call("git checkout $branch_name",combine=>1);print$output}elsif (scalar grep {/^remotes\/origin\/\Q$branch_name\E$/i}@branches){my ($output)=App::Task::Base->system_call("git checkout --track -b $branch_name origin/$branch_name");print$output}else {App::Task::Base->system_call("git checkout --no-track -b $branch_name $start_ref");print "Created and switched to branch '$branch_name' from $start_ref\n";if ($start_ref eq "origin/$mainline_branch"){App::Task::Base->system_call("git branch --set-upstream $branch_name $start_ref")}}$self->_clear_all_branches;$self->current_branch($branch_name);return$branch_name}sub add_files_to_new_deployment_branch {my ($self,$branch,$files)=@_;die "No branch specified to add files to" if!$branch;my$original_branch=$self->get_current_branch;my$current_dir=getcwd;my$branch_name=$self->create_deployment_branch($branch);$self->_add_files_to_branch(source_branch=>$original_branch,target_branch=>$branch_name,current_dir=>$current_dir,files=>$files,);return$branch_name}sub _add_files_to_branch {my ($self,%args)=@_;my$original_branch=$args{source_branch}or die 'no target branch';my$branch_name=$args{target_branch}or die 'no target branch';my$current_dir=$args{current_dir}|| getcwd;my@files=@{$args{files}|| []};chdir$self->get_repository_root;my$file_list=join(' ',map {"'$_'"}@files);App::Task::Base->system_call("git checkout $original_branch $file_list");App::Task::Base->system_call("git commit -n -m \"Added files: $file_list to branch $branch_name from branch $original_branch\"",ignore_exit_status=>1);App::Task::Base->system_call("git checkout $original_branch");chdir$current_dir;if ($original_branch ne $branch_name){print "Added the following " .(scalar(@files)==1 ? 'file' : 'files')." from branch '$original_branch' into branch '$branch_name': $file_list\n"}else {print((scalar(@files)==1 ? 'File is' : 'Files are')." already in branch '$branch_name': $file_list\n")}}sub get_deployed_envs {my ($self,$branch_name)=@_;my ($remote_branches)=App::Task::Base->system_call("git branch -r --contains $branch_name");my%env_names=map {$_=>1}keys %{App::Task::Base->environments};my%deployed_envs;for my$raw_branch (split("\n",$remote_branches)){my ($remote)=$raw_branch =~ / *\*? *origin\/(\w+)$/;next if!$remote;next if!exists$env_names{$remote};$deployed_envs{$remote}=1}return \%deployed_envs}sub get_current_branch {my ($self)=@_;return$self->current_branch}sub _build_current_branch {my ($self)=@_;my ($branches)=App::Task::Base->system_call("git branch");my ($current_branch)=$branches =~ /^\* ([^\n]+)/ims;return$current_branch}sub _build_all_branches {my ($self)=@_;my ($branches)=App::Task::Base->system_call("git branch -a");my@branches;for my$branch (split /^/,$branches){chomp$branch;$branch =~ s/^(\*?)[ \t]*(.*)[ \t]*$/$2/;$self->current_branch($branch)if $1;push@branches,$branch}return \@branches}sub unique_branches {my ($self)=@_;my (%branches,@branches);for my$branch (@{$self->all_branches}){my$non_origin_branch=$branch;$non_origin_branch =~ s/^remotes\/origin\///;next if exists$branches{$non_origin_branch};$branches{$non_origin_branch}=1;push@branches,$non_origin_branch}return \@branches}sub get_branches_by_prefix {my ($self,$prefix)=@_;my@branches=@{$self->unique_branches};my@matches=grep {/^\Q$prefix/}@branches;return@matches}sub get_branch_name {my ($self,$branch)=@_;if ($branch){my@existing_branches_matching=$self->get_branches_by_prefix($branch);if (grep {$_ eq $branch}@existing_branches_matching){return$branch}@existing_branches_matching=grep {!/[\/-]deploy\d+$/}@existing_branches_matching;if (@existing_branches_matching > 1){die "Ambiguous branch specified $branch:\n",join("\n",map "  $_",@existing_branches_matching)}if (@existing_branches_matching){return$existing_branches_matching[0]}return$branch}else {return$self->get_current_branch}}sub get_next_deployment_branch_name {my ($self,$branch)=@_;my@existing=$self->get_all_deployment_branches($branch);my$deployment_branch_count=0;for my$branch_name (@existing){if ($branch_name =~ /[\/-]deploy(\d+)$/i){$deployment_branch_count=$1 if $1 > $deployment_branch_count}}return "$branch-deploy" .($deployment_branch_count + 1)}sub get_all_deployment_branches {my ($self,$branch)=@_;my@branches=@{$self->unique_branches};my%deployment_branches;for my$branch_name (@branches){if ($branch_name =~ /^($branch[\/-]deploy(\d+))/ims){$deployment_branches{$2}=$1}}return map {$deployment_branches{$_}}sort {$a <=> $b}keys%deployment_branches}sub get_changed_files {my ($self,$branch,$commit_id,%options)=@_;my$branch_name;if ($options{branch_name}){$branch_name=$options{branch_name}}else {$branch_name=$self->get_branch_name($branch)}my ($file_list,$error,$exit_status)=App::Task::Base->system_call("git diff --name-only \$(git merge-base $branch_name $commit_id) $branch_name",ignore_exit_status=>1);chomp$file_list;my@files=map {s/^\s*|\s*$//ms;$_}split(/\n/,$file_list);return@files}sub safe_merge {my ($self,$merge_branch_name,$env_name,$target_branch,$options,$action)=@_;my$target_branch_name=App::Task::Base->environments->{$env_name}{branch_name};my ($merge_output,$merge_errors,$exit_status)=App::Task::Base->system_call("git merge $options $merge_branch_name",ignore_exit_status=>1);if ($exit_status){my@bad_files=$self->get_conflicted_files;my$remote_task_branch_exclude='';if ($action eq 're-ready'){print "merging local branch $merge_branch_name into $env_name/$merge_branch_name failed\n";$remote_task_branch_exclude=" ^$target_branch"}elsif ($action eq 'ready'){print "merging local branch $merge_branch_name into origin/$target_branch_name to create $merge_branch_name on $env_name failed\n"}elsif ($action eq 'deploy'){print "merging local branch $merge_branch_name into origin/$target_branch_name failed\n"}else {print "merging local branch $merge_branch_name into $target_branch failed\n"}print "See the entire problem through 'git diff ^origin/$target_branch_name$remote_task_branch_exclude $merge_branch_name'\n";print "This probably means that another task that has been pushed to $env_name conflicts with branch $merge_branch_name. 'git blame' on conflicting files and git branch -r contains <commit_id> for lines with conflicts, should give you enough information to find out which task branch is conflicting. It is recommended to add one branch to the other and make one dependent on the other to make it so you won't have to fix conflicts at every environment deploy\n\n";print "-----------------\n\n";print `git diff`;print "\n\nHow do you want to resolve this conflict?\n";my$response=App::Task::Base->prompt(s=>'open a shell to fix the merge manually',default=>'reset',);eval {if ($response =~ /open a shell/i){print "Fix your conflict and commit\n";print "Exit shell to finish the deployment\n";system('bash')}else {die "Exiting"}my@remaining_bad_files=$self->get_conflicted_files;if (@remaining_bad_files){die "You didn't fix: @remaining_bad_files\n"}print "conflicts resolved\n"};if ($@){print "Resetting merge...\n";App::Task::Base->system_call("git reset --merge");die color('red')."Can't continue after a failed merge to environment: $env_name\n$@\n" .color('reset')}}}sub get_conflicted_files {my$self=shift;my$output=`git status -s`;chomp$output;my@files=split("\n",$output);my$relative_to_root=`git rev-parse --show-cdup`;chomp$relative_to_root;my@conflicted_files;for my$file (@files){if (my ($path)=$file =~ /^ *U\w+ *(.*)/){push@conflicted_files,"$relative_to_root$path"}}return@conflicted_files}sub update_remotes {my ($self)=@_;if (App::Task::Config->get_option('needs-update')){my$msg="Updating remote git repositories...";print$msg if is_interactive();App::Task::Base->system_call("git remote update --prune");printf("\r%s\r",' ' x length($msg))if is_interactive();App::Task::Config->set_option('needs-update'=>0)}}1;
APP_TASK_CONTENTTRACKER

$fatpacked{"App/Task/Hooks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_HOOKS';
  package App::Task::Hooks;use Moo;use App::Task::Config;sub default_env {my$config=App::Task::Config->config;return (TASK_REPO_ROOT=>$config->{repo_root},)}sub find_hooks {my ($self,$command,$hook_name)=@_;my@hooks;my$hooks=$command->env->{hooks};if ($hooks && $hooks->{$hook_name}){push@hooks,@{$hooks->{$hook_name}}}my$global_hooks=App::Task::Config->config->{hooks};if ($global_hooks && $global_hooks->{$hook_name}){push@hooks,@{$global_hooks->{$hook_name}}}return@hooks}sub run_hooks {my ($self,$command,$hook_name,$env)=@_;my@hooks=$self->find_hooks($command,$hook_name);{local%ENV=(%ENV,$self->default_env,%{$env || {}},);for my$hook (@hooks){my$ok=$self->run_hook($command,$hook_name,$hook);if (!$ok){return}}}return 1}sub run_hook {my ($self,$command,$hook_name,$hook)=@_;my$root=App::Task::Config->config->{repo_root};my$hook_path="$root/$hook";my$prelude="Hook '$hook_path' for $hook_name";if (!-e $hook_path){warn "$prelude doesn't exist, skipping";return 1}if (!-x $hook_path){warn "$prelude isn't executable, skipping";return 1}my$system_ret=system($hook_path);if ($system_ret){if ($?==-1){warn "$prelude couldn't be executed: $!"}elsif ($? & 127){warn "$prelude exited with signal ",($? & 127)}else {warn "$prelude exited with nonzero status ",$? >> 8}return 0}else {return 1}}1;
APP_TASK_HOOKS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE



use strict;
use warnings;
$|++;

use App::Task::Base;
use App::Task::Command::Start;
use App::Task::Command::Ready;
use App::Task::Command::Deploy;
use App::Task::Command::Status;
use App::Task::Command::Cleanup;

my $task = App::Task::Base->new;
$task->run;
