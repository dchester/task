#!/usr/bin/env perl

our $VERSION = "4.00";

# DO NOT EDIT -- this is an auto generated file

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Task/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_BASE';
  package App::Task::Base;use Moo;use IO::CaptureOutput qw(capture_exec capture_exec_combined);use IO::Interactive qw(is_interactive);use Getopt::Long;use Term::ANSIColor;use App::Task::ContentTracker;use App::Task::Config;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through require_order));our$VERSION='4.00';my$instance;sub instance {return$instance if$instance;die __PACKAGE__ .' instance has not been built yet'}sub BUILD {my ($self,$args)=@_;if (my$message=App::Task::Config->configure($args->{config_file})){usage($message)}$instance=$self;GetOptions('help|h'=>sub {usage()},'verbose|v+'=>\($App::Task::Config::options{verbose}),)or usage()}sub run {my ($self)=@_;my$content_tracker=App::Task::ContentTracker->new;my$command_name=shift@ARGV;usage()if!$command_name;my$command=App::Task::Config->find_command($command_name);if (!$command){usage("Invalid command: $command_name")}my$command_instance=$command->{module}->new(content_tracker=>$content_tracker,);$command_instance->run}sub prompt {my ($self,%options)=@_;$self=instance()if!ref$self;print 'Enter ' .join(', ',map {"'$_' to $options{$_}"}grep {!/default/}keys%options).', anything else to exit: ';chomp(my$response=<STDIN>);if (defined$options{lc$response}){return$options{lc$response}}elsif (defined$options{default}){return$options{default}}else {print "Exiting...\n";exit}}sub system_call {my ($self,$command,%options)=@_;$self=ref$self ? $self : instance();$command=[$command ]if!ref$command;my$command_text=join(' ',@$command);if (App::Task::Config->get_option('verbose')&& App::Task::Config->get_option('verbose')>= 1 || $options{verbose}){printf("\r%s\r",' ' x 80)if is_interactive();print "* $command_text\n"}my ($stdout,$stderr);if ($options{combine}){($stdout)=capture_exec_combined(@$command)}else {($stdout,$stderr)=capture_exec(@$command)}my$exit_status=$? & 127 ? $? & 127 : $? >> 8;my$output='';if ($stdout){chomp(my$stdout_copy=$stdout);$stdout_copy =~ s/(?!\A)^/** /gims;$output .= "** stdout: '$stdout_copy'\n"}if ($stderr){chomp(my$stderr_copy=$stderr);$stderr_copy =~ s/(?!\A)^/** /gims;$output .= "** stderr: '$stderr_copy'\n"}if (!defined$options{ignore_exit_status}and $exit_status){$self->highlighted_die("Command failed: $command_text\n$output\n")}if (App::Task::Config->get_option('verbose')&& App::Task::Config->get_option('verbose')>= 2){print$output}return ($stdout,$stderr,$exit_status)}sub highlighted_die {my ($self,$message)=@_;$message =~ s/(\n?)\z/color('reset') . $1/e;die color('red').$message}sub environments {my ($class)=@_;return App::Task::Config->config->{environments}}sub usage {my ($message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";for my$command_name (App::Task::Config->command_list){printf "    %-12s %s\n",$command_name,App::Task::Config->find_command($command_name)->{description}}print "\nUse 'task <subcommand> --help' for more information\n";exit 1}no Moo;1;
  Usage: task <subcommand>
  
  task is a release management tool for git designed to aid multi-user
  development in tiny chunks (task branches). It supports
  multiple environments and can build de facto releases (defined by whatever is
  on a given branch) or versioned releases
  
  Available subcommands are:
  END_USAGE
APP_TASK_BASE

$fatpacked{"App/Task/Command.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND';
  package App::Task::Command;use Moo::Role;use Types::Standard qw(ArrayRef HashRef InstanceOf);use Cwd qw(getcwd);use Getopt::Long;Getopt::Long::Configure(qw(no_ignore_case bundling pass_through permute));has 'environment'=>(is=>'ro',isa=>HashRef,reader=>'get_environment');has 'content_tracker'=>(is=>'ro',required=>1,isa=>InstanceOf['App::Task::ContentTracker'],reader=>'content_tracker');has 'task_branch'=>(is=>'rw');has 'original_dir'=>(is=>'ro',default=>sub {getcwd()},reader=>'get_original_dir');has 'allow_branch_switch'=>(is=>'rw',default=>sub {0});has 'deployment_branch'=>(is=>'rw',reader=>'get_deployment_branch',writer=>'set_deployment_branch');requires 'run';requires 'usage';around 'run'=>sub {my ($next,$self,%options)=@_;my$original_branch=$self->content_tracker->get_current_branch;$self->content_tracker->update_remotes;my@returned_values;eval {@returned_values=$next->($self)};my$error;if ($@){$error=$@}$self->return_to_original_dir;my$current_branch=$self->content_tracker->get_current_branch;if ($current_branch ne $original_branch and!$self->allow_branch_switch){App::Task::Base->system_call("git checkout '$original_branch'")}die$error if$error;return (@returned_values)};sub return_to_original_dir {my ($self)=@_;my$current_dir=getcwd;my$original_dir=$self->get_original_dir;if ($original_dir ne $current_dir){chdir$self->get_original_dir or die "Couldn't change back to $original_dir from $current_dir"}}sub set_environment {my ($self,$env)=@_;if ($env){$self->{environment}=App::Task::Base->environments->{$env}or die "Invalid destination environment: $env"}else {my$destination_env=shift@ARGV;$self->usage("error: No environment specified")if!defined$destination_env;$self->{environment}=App::Task::Base->environments->{$destination_env};if (!defined$self->{environment}){$self->usage("error: '$destination_env' is not a valid environment\nvalid environments are: " .join(', ',sort keys %{App::Task::Base->environments}))}}}sub env {my ($self)=@_;return$self->{environment}}sub add_task {my ($self,$branch_name)=@_;if (my ($valid_branch)=sort$self->content_tracker->get_branches_by_prefix($branch_name)){$self->task_branch($valid_branch);return 1}return 0}sub resolve_file {my ($self,$path)=@_;my$relative_to_root=`git rev-parse --show-cdup`;chomp$relative_to_root;if (-e $path){if ($relative_to_root){return abs2rel(abs_path(rel2abs$path),$self->content_tracker->get_repository_root)}else {return$path}}return$path if -e "$relative_to_root$path";die "Couldn't find file: $path"}sub parse_options {my ($self,%options)=@_;$options{'verbose|v+'}=\($App::Task::Config::options{verbose});GetOptions(%options)or $self->usage};no Moo::Role;no Types::Standard;1;
APP_TASK_COMMAND

$fatpacked{"App/Task/Command/Cleanup.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_CLEANUP';
  package App::Task::Command::Cleanup;use Moo;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(cleanup=>'Cleanup branches that have been deployed or abandoned');sub BUILD {my ($self,$args)=@_;my$deployed_to_env='prod';my$days=7;$self->parse_options('help|h'=>sub {$self->usage},'delete|d'=>sub {App::Task::Config->set_option('delete-task-branches'=>1)},'days=i'=>\$days,'deployed-to=s'=>\$deployed_to_env,);die "Invalid env '$deployed_to_env'" if!defined App::Task::Base->environments->{$deployed_to_env};App::Task::Config->set_option('deployed-to'=>$deployed_to_env);App::Task::Config->set_option('days-since-last-commit'=>$days);for my$arg (@ARGV){if (!$self->add_task($arg)){print "Unknown option: $arg\n"}}}sub run {my ($self)=@_;$self->content_tracker->update_remotes;my ($local_branches)=App::Task::Base->system_call("git branch");my ($current_branch)=$local_branches =~ /^\* ([^\n]+)/ims;LOCAL_BRANCH: for my$raw_branch (split /\n/,$local_branches){my ($branch_name)=$raw_branch =~ /^\*?[ \t]*\b(.*)/ims;next LOCAL_BRANCH if!$branch_name;next LOCAL_BRANCH if$self->task_branch !~ /^\Q$branch_name/;my ($deployed_envs)=$self->content_tracker->get_deployed_envs($branch_name);my$target_env=App::Task::Config->get_option('deployed-to');if (defined$deployed_envs->{integration}and defined$deployed_envs->{$target_env}){chomp(my ($last_commit_timestamp)=App::Task::Base->system_call("git log -1 --pretty=format:'%ct' '$target_env/$branch_name'",ignore_exit_status=>1));if (!$last_commit_timestamp){chomp(my ($sha1)=App::Task::Base->system_call("git rev-parse $branch_name"));chomp(($last_commit_timestamp)=App::Task::Base->system_call("git log -1 --pretty=format:'%ct' '$sha1'"))}my$actual_days_since_last_commit=int((time()- $last_commit_timestamp)/ 86400);if ($actual_days_since_last_commit >= App::Task::Config->get_option('days-since-last-commit')){print "Branch '$branch_name' has existed on $target_env for $actual_days_since_last_commit days and can be deleted\n";if (App::Task::Config->get_option('delete-task-branches')){system("git branch -D '$branch_name'")}}}}}sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task cleanup [-hd] <branch_name>
  
  Show (and delete) task branches that have been deployed to production or another environment
  
  Options:
  
      -h, --help                   Show a brief help message and exit
      -n, --noconfirm  Don't show a confirmation message before doing the deploy
      -d, --delete                 Delete the branches that exist on the target
                                   environment
      --deployed-to=<environment>  Sets the target environment for which task
                                   branches must have been deployed to.
                                   Defaults to what your mainline branch is set to
      --days=<number>              Make sure the task branches have existed on the
                                   target environment for at least this many days
  
  Examples:
  
      task cleanup
  
  Show local branches whose tips have existed on prod for at least 7 days
  
      task cleanup -d
  
  Delete local branches whose tips have existed on prod for at least 7 days
  END_USAGE
APP_TASK_COMMAND_CLEANUP

$fatpacked{"App/Task/Command/Deploy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_DEPLOY';
  package App::Task::Command::Deploy;use Moo;use Cwd qw(getcwd);use Term::ANSIColor;use App::Task::Config;use App::Task::Hooks;with 'App::Task::Command';App::Task::Config->register_command(deploy=>'Deploy a task branch to a given environment (and all its dependent envs too)');sub highlighted_die {my ($message)=@_;$message =~ s/(\n?)\z/color('reset') . $1/e;die color('red').$message}sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},'noconfirm|n'=>sub {App::Task::Config->set_option('noconfirm'=>1)},'again'=>sub {App::Task::Config->set_option('redeploy'=>1)},);$self->set_environment($args->{destination_environment});my$branch_name=$self->env->{branch_name};$self->content_tracker->update_remotes;my ($branch_tip)=App::Task::Base->system_call("git rev-parse 'origin/$branch_name'");chomp$branch_tip;if (scalar@ARGV and!$self->task_branch){my@files;while (my$arg=pop@ARGV){if ($arg =~ /-deploy\d+$/ && $self->add_task($arg)){$self->set_deployment_branch($arg)}elsif (!$self->add_task($arg)){my$file=$self->resolve_file($arg);push@files,$file}}if (@files){my$deployment_branch=$self->content_tracker->add_files_to_new_deployment_branch($self->task_branch,\@files);$self->set_deployment_branch($deployment_branch)}}}sub run {my ($self)=@_;my$current_dir=getcwd;my$env_name=$self->env->{name};my@branches;TASK: my$task_branch=$self->task_branch;my$ready=App::Task::Command::Ready->new(destination_environment=>$self->env->{name},content_tracker=>$self->content_tracker,deployment_branch=>$self->get_deployment_branch,);$ready->add_task($task_branch);my$branch_name=$ready->run;push(@branches,$branch_name);my@unpushed_files;my@deployment_branches;my$target_branch_name=$self->env->{branch_name};$task_branch=$self->task_branch;my$current_branch_name=$self->content_tracker->get_branch_name($task_branch);my$deployment_branch_name=$self->get_deployment_branch || $current_branch_name;my@files=$self->content_tracker->get_changed_files($task_branch,"origin/$target_branch_name",branch_name=>$deployment_branch_name);push(@unpushed_files,@files);if (App::Task::Config->get_option('redeploy')){my ($file_list,$err,$exit_status)=App::Task::Base->system_call("git diff --name-only origin/master...$env_name/$deployment_branch_name",ignore_exit_status=>1);if (!$exit_status){chomp$file_list;my@files=map {s/^\s*|\s*$//ms;$_}split(/\n/,$file_list);push(@unpushed_files,@files)}}push@deployment_branches,$deployment_branch_name;my$changed_file_count=scalar@unpushed_files;if ($changed_file_count){print "$changed_file_count " .($changed_file_count > 1 ? 'files' : 'file')." to deploy to $env_name\n"}else {print "No changed files to deploy to $env_name";print "\n\n";return}my$remote_files=join(' ',map {"'$_'"}@unpushed_files);my$original_branch=$self->content_tracker->get_current_branch;my$temp_branch_exists=0;eval {my%merged_branches;my$temp_branch_name="temp_deploy_${env_name}";App::Task::Base->system_call("git checkout --track -b '$temp_branch_name' origin/$target_branch_name");$temp_branch_exists=1;for my$deployment_branch_name (@deployment_branches){if ($env_name eq 'integration'){$self->content_tracker->safe_merge($deployment_branch_name,$env_name,'integration','','deploy')}else {$self->content_tracker->safe_merge("origin/$env_name-ready/$deployment_branch_name",$env_name,$temp_branch_name,'--ff-only','deploy')}$merged_branches{$deployment_branch_name}=1}my ($diffstat)=App::Task::Base->system_call("git diff --stat=120,100 'origin/$target_branch_name'..'$temp_branch_name'");print "Deploying the following changes to $env_name:\n$diffstat\n";if (!App::Task::Config->get_option('noconfirm')){print "Enter 'y' to continue, anything else to exit: ";chomp(my$response=<STDIN>);if (lc$response ne 'y'){$self->return_to_original_dir;App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D 'temp_deploy_$env_name'");exit}}App::Task::Base->system_call("git pull origin '$target_branch_name'");App::Task::Base->system_call("git push origin 'temp_deploy_$env_name:$target_branch_name'");print "Updated git $env_name branch\n";App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -d 'temp_deploy_$env_name'");$temp_branch_exists=0;my$current_dir=getcwd;my%deployed_branches;for my$branch_name (@branches){$deployed_branches{$branch_name}++}chomp(my ($deploy_sha)=App::Task::Base->system_call("git rev-parse HEAD"));my$hooks_ok=App::Task::Hooks->run_hooks($self,'post_deploy',{TASK_DEPLOY_ENVIRONMENT=>$env_name,TASK_DEPLOY_SHA=>$deploy_sha,});die "Failed to run hooks" unless$hooks_ok;if ($self->env->{branch_name}eq App::Task::Config->config->{mainline_branch}and $self->env->{dependent_environment}){App::Task::Config->set_option('needs-update'=>1);$self->content_tracker->update_remotes;my$dependent_env_name=$self->env->{dependent_environment};$self->merge_back_to_dependent_environments($env_name,$dependent_env_name)}chdir$current_dir or highlighted_die "Couldn't chdir to: $current_dir"};if ($@){$self->return_to_original_dir;App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D 'temp_deploy_$env_name'")if$temp_branch_exists;die $@}else {print color 'green';print "finished deploying to $env_name\n\n";print color 'reset'}}sub merge_back_to_dependent_environments {my ($self,$top_level_env,$dependent_env_name)=@_;my$top_level_env_branch=App::Task::Base->environments->{$top_level_env}{branch_name};my$dependent_env_branch=App::Task::Base->environments->{$dependent_env_name}{branch_name};my$temp_branch_name="temp_merge_${top_level_env}_back_to_${dependent_env_name}";App::Task::Base->system_call("git checkout -b '$temp_branch_name' origin/$dependent_env_branch");$self->content_tracker->safe_merge("origin/$top_level_env_branch",$dependent_env_name,"origin/$dependent_env_branch",'','');App::Task::Base->system_call("git push origin '$temp_branch_name:$dependent_env_branch'");App::Task::Base->system_call("git checkout master");App::Task::Base->system_call("git branch -D '$temp_branch_name'");print "Merged changes from $top_level_env back to $dependent_env_name\n";if (my$next_dependent_env=App::Task::Base->environments->{$dependent_env_name}{dependent_environment}){$self->merge_back_to_dependent_environments($top_level_env,$next_dependent_env)}else {return}}no Moo;sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task deploy [-hn] [--again] environment <branch_name>
  
  Merge and deploy task branches
  
  Options:
  
      -h, --help       Show a brief help message and exit
      -n, --noconfirm  Don't show a confirmation message before doing the deploy
      --again          Ignore if a branch has already been deployed to an
                       environment and re-deploy again anyway. Basically this
                       will rerun your hooks for this environment without merging
                       anything
  END_USAGE
APP_TASK_COMMAND_DEPLOY

$fatpacked{"App/Task/Command/Ready.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_READY';
  package App::Task::Command::Ready;use Moo;use Term::ANSIColor;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(ready=>'Pre-merge a task branch with an environment branch for later deployment');sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},);$self->set_environment($args->{destination_environment});if (scalar@ARGV and!$self->task_branch){my@files;while (my$arg=pop@ARGV){if ($arg =~ /-deploy\d+$/ && $self->add_task($arg)){$self->set_deployment_branch($arg)}elsif (!$self->add_task($arg)){my$file=$self->resolve_file($arg);push@files,$file}}if (@files){my$deployment_branch=$self->content_tracker->add_files_to_new_deployment_branch($self->task_branch,\@files);$self->set_deployment_branch($deployment_branch)}}}sub run {my ($self)=@_;my$is_final_command=(caller(4))[0]=~ /^App::Task::Base$/ ? 1 : 0;my (@changed_files,@ready_tasks,$diff_stat);my$env_name=$self->env->{name};my ($remotes)=App::Task::Base->system_call("git remote");my%remotes=map {$_=>1}split(/\n/,$remotes);if (!exists$remotes{'origin'}){die color('red')."You don't have a remote set up. Please re-clone the repository" .color('reset')}my$original_branch=$self->content_tracker->get_current_branch;my$merge_commit_id;my$repository_root=$self->content_tracker->get_repository_root;my$task_branch=$self->task_branch;my$branch_name=$self->content_tracker->get_branch_name($task_branch);my$deployment_branch_name=$self->get_deployment_branch || $branch_name;my$deployed_envs=$self->content_tracker->get_deployed_envs($deployment_branch_name);my$dependent_env=$self->env->{dependent_environment};if (defined$dependent_env and!exists$deployed_envs->{$dependent_env}){my$dependent_deploy=App::Task::Command::Deploy->new(destination_environment=>$self->env->{dependent_environment},content_tracker=>$self->content_tracker,deployment_branch=>$self->get_deployment_branch,);$dependent_deploy->add_task($task_branch);$dependent_deploy->run}App::Task::Base->system_call("git checkout $original_branch");my$remote_task_branch_name='';if ($env_name eq 'integration'){($remote_task_branch_name)=map {/^\s*(origin\/$deployment_branch_name)$/ims ? $1 : ()}`git branch -r`}else {($remote_task_branch_name)=map {/^\s*(origin\/$env_name-ready\/$deployment_branch_name)$/ims ? $1 : ()}`git branch -r`}my$temp_branch_name="temp_${env_name}_merge_$deployment_branch_name";my$allow_ready=$self->env->{allow_ready};eval {my$diff_branch=$temp_branch_name;my$env_branch_name=App::Task::Base->environments->{$env_name}{branch_name};if ($remote_task_branch_name){App::Task::Base->system_call("git checkout -b $temp_branch_name $remote_task_branch_name")}elsif ($allow_ready){App::Task::Base->system_call("git checkout -b $temp_branch_name origin/$env_branch_name")}else {App::Task::Base->system_call("git checkout -b $temp_branch_name $deployment_branch_name");$diff_branch="origin/$env_branch_name"}@changed_files=$self->content_tracker->get_changed_files($task_branch,$diff_branch,branch_name=>$deployment_branch_name);if ($is_final_command){($diff_stat)=App::Task::Base->system_call("git diff -p --stat --color '$diff_branch'...'$deployment_branch_name'",ignore_exit_status=>1)}$self->content_tracker->safe_merge($deployment_branch_name,$env_name,$temp_branch_name,'--no-ff --log',$remote_task_branch_name ? 're-ready' : 'ready');if ($allow_ready){$self->content_tracker->safe_merge("origin/$env_branch_name",$env_name,$temp_branch_name,'--no-ff --log',$remote_task_branch_name ? 're-ready' : 'ready')}chomp(($merge_commit_id)=App::Task::Base->system_call("git rev-parse '$temp_branch_name'"));push(@ready_tasks,$task_branch);if ($env_name eq 'integration'){App::Task::Base->system_call("git push origin 'HEAD:$deployment_branch_name'")}else {App::Task::Base->system_call("git push origin 'HEAD:$env_name-ready/$deployment_branch_name'")}App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D $temp_branch_name")};if ($@){App::Task::Base->system_call("git checkout $original_branch");App::Task::Base->system_call("git branch -D $temp_branch_name",ignore_exit_status=>1);App::Task::Base->instance->highlighted_die($@)}my$changed_file_count=scalar@changed_files;if ($changed_file_count){print "\n$changed_file_count " .($changed_file_count > 1 ? 'files' : 'file')." ready for $env_name\n"}else {print "\nNo changed files to set as ready for $env_name\n";return}print join('',map {"\t$deployment_branch_name\t$_\n"}@changed_files);print "\n";print "ready for $env_name - commit id: $merge_commit_id\n";my$github_url=App::Task::Config->config->{github_url};my$env_branch_name=App::Task::Base->environments->{$env_name}{branch_name};if ($github_url){print "View the full diff here: $github_url/compare/$env_branch_name...$merge_commit_id\n"}return$deployment_branch_name}sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task ready [-hn] environment <branch_name>
  
  Pre-merge task branches and set them as ready for deployment without actually deploying them
  
  Options:
  
      -h, --help     Show a brief help message and exit
  END_USAGE
APP_TASK_COMMAND_READY

$fatpacked{"App/Task/Command/Start.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_START';
  package App::Task::Command::Start;use Moo;use App::Task::Config;with 'App::Task::Command';App::Task::Config->register_command(start=>'Start work on a new or existing task branch');sub BUILD {my ($self,$args)=@_;$self->parse_options('help|h'=>sub {$self->usage},);my$arg=shift@ARGV;if ($arg){$self->task_branch($arg)}$self->{allow_branch_switch}=1;$self->usage("No feature branch name specified to start work on")if!$self->task_branch}sub run {my ($self)=@_;$self->content_tracker->update_remotes;if (my$branch=$self->task_branch){$self->create_task_branch($branch)}}sub create_task_branch {my ($self,$branch)=@_;my$branch_name=$self->content_tracker->get_branch_name($branch);$self->content_tracker->_create_branch($branch_name)}sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task start [-h] <branch_name>
  
  Properly starts a task branch from your mainline branch
  
  Options:
  
      -h, --help     Show a brief help message and exit
  
  Examples:
  
      task start feature/docs
  
      creates a branch feature/docs from origin/master
      or checks it out if someone else already created it
  END_USAGE
APP_TASK_COMMAND_START

$fatpacked{"App/Task/Command/Status.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_COMMAND_STATUS';
  package App::Task::Command::Status;use Moo;use Types::Standard qw(HashRef ArrayRef);use Term::ANSIColor;use IO::Interactive qw(is_interactive);use App::Task::Config;with 'App::Task::Command';has 'envs'=>(is=>'ro',isa=>HashRef,default=>sub {{}});has 'visited_commits'=>(is=>'rw',isa=>HashRef,default=>sub {return {}});has 'args'=>(is=>'rw',isa=>HashRef,default=>sub {return {}});has 'ordered_envs'=>(is=>'lazy',isa=>ArrayRef);has 'indent'=>(is=>'rw',default=>sub {0});has 'columns'=>(is=>'lazy');$|=1;App::Task::Config->register_command(status=>'View the status of a task branch');sub _build_columns {my$self=shift;return unless is_interactive();my ($wchar)=$ENV{COLUMNS}|| 80;return$wchar - 2};sub BUILD {my ($self,$args)=@_;$self->args->{color}=1 if is_interactive();$self->parse_options('help|h'=>sub {$self->usage},'diff|p!'=>\$self->args->{diff},'diff-options=s'=>\$self->args->{diff_options},'log|l!'=>\$self->args->{log},'log-options=s'=>\$self->args->{log_options},'color|colour|c!'=>\$self->args->{color},'all-commits!'=>\$self->args->{all_commits},'name-only!'=>\$self->args->{name_only},);my@new_argv;if (!scalar@ARGV){my$current_branch=$self->content_tracker->get_current_branch;$self->add_task($current_branch)}for my$arg (@ARGV){if (!$self->add_task($arg)){push(@new_argv,$arg)}}if (scalar@new_argv){$self->abort("Unrecognized option: '@new_argv'")}$self->usage if!$self->task_branch}sub _build_ordered_envs {my$self=shift;my$environments=App::Task::Base->environments;my ($current_top_level_env)=map {$environments->{$_}{branch_name}eq App::Task::Config->config->{mainline_branch}? $_ : ()}keys %$environments;my@ordered_envs;while ($current_top_level_env && defined$environments->{$current_top_level_env}){push(@ordered_envs,$current_top_level_env);push(@ordered_envs,"ready for $current_top_level_env")if$environments->{$current_top_level_env}{allow_ready};$current_top_level_env=$environments->{$current_top_level_env}{dependent_environment}|| undef}push(@ordered_envs,'Un-merged changes');return \@ordered_envs}sub increase_indent {my$self=shift;$self->indent($self->indent()+ 4)}sub decrease_indent {my$self=shift;$self->indent($self->indent()- 4)}sub print_indented {my ($self,$text)=@_;print " " x $self->indent(),$text,"\n"}sub get_status {my ($self,$task_branch_name)=@_;chomp(my ($merged_to_master)=App::Task::Base->system_call("git rev-list -n 1 origin/master ^$task_branch_name"));my$master_before_merge=$merged_to_master ? "$merged_to_master^" : "origin/master";chomp(my ($merge_base)=App::Task::Base->system_call("git merge-base $master_before_merge $task_branch_name"));my$start=$merge_base;my$definitive_branch=$task_branch_name;my@branch_commits=$self->get_rev_list($start,$definitive_branch);unless (@branch_commits){$definitive_branch="origin/$task_branch_name";@branch_commits=$self->get_rev_list($start,$definitive_branch)}my%env_commits=$self->get_env_commits(start=>$start,branch=>$task_branch_name,branch_commits=>\@branch_commits,);return (env_commits=>\%env_commits,branch_commits=>\@branch_commits,)}sub get_env_commits {my ($self,%args)=@_;die "start not specified" if!$args{start};die "branch not specified" if!$args{branch};my$branch=$args{branch};my@envs=@{$self->ordered_envs};my@branch_rev_list=$args{branch_commits}? @{$args{branch_commits}}: $self->get_rev_list($args{start},$branch);$self->die_no_commits($branch)unless (@branch_rev_list);my%branch_rev_hash=map {$_=>1}@branch_rev_list;my%env_commits;my$prev_env;for my$env (@envs){my ($remote_branch,$repo)=$self->get_remote_branch_for_env($env,$branch);$remote_branch=$repo ? "$repo/$remote_branch" : $remote_branch;my$len=print_disappearing(msg=>"Fetching rev-list for '$env'...");my%remote_rev_list=map {exists$branch_rev_hash{$_}? ($_=>1): ()}$self->get_rev_list($args{start},$remote_branch);print_disappearing(len=>$len);$env_commits{$env}={abs_commits=>{list=>[],hash=>{}},rel_commits=>{list=>[],hash=>{}},};for my$commit (@branch_rev_list){if ($remote_rev_list{$commit}){push @{$env_commits{$env}->{abs_commits}->{list}},$commit;$env_commits{$env}->{abs_commits}->{hash}->{$commit}=1}}$env_commits{$env}->{branch_start_name}=$args{start};chomp(my ($start_ref)=App::Task::Base->system_call("git show-ref $args{start}",ignore_exit_status=>1,));$start_ref ||=$args{start};$env_commits{$env}->{branch_start_ref}=(split(/\s+/,$start_ref))[0];$env_commits{$env}->{branch_tip}=$env_commits{$env}->{abs_commits}->{list}->[0]|| '';if ($prev_env && $env_commits{$env}->{branch_tip}eq $env_commits{$prev_env}->{branch_tip}){$env_commits{$env}->{same_as_prev_env}=1}for my$commit (@{$env_commits{$env}->{abs_commits}->{list}}){my$prev_branch_tip=$prev_env && $env_commits{$prev_env}->{branch_tip};if ($prev_env && $prev_branch_tip && $commit eq $prev_branch_tip){$prev_env=$env;last}push @{$env_commits{$env}->{rel_commits}->{list}},$commit;$env_commits{$env}->{rel_commits}->{hash}->{$commit}=1}$prev_env=$env}return%env_commits}sub die_no_commits {my$self=shift;my ($branch)=@_;chomp(my ($stdout)=App::Task::Base->system_call("git branch -a"));my@all_branches=grep {s/^..//}split("\n",$stdout);my@branches=grep {m{(\w+/)*$branch}}@all_branches;if (@branches){warn$self->print_color(['red'],"The branch: '$branch' exists on the repositories below, but has no commits."),"\n";$self->increase_indent;$self->print_indented($_)for@branches;$self->decrease_indent;die "\n"}else {die$self->print_color(['red'],"The branch: '$branch' does not exist locally, or on any remote."),"\n"}}sub print_disappearing {my (%args)=@_;return unless is_interactive();if ($args{msg}){print$args{msg};return length$args{msg}}elsif ($args{len}){my$spaces=(' ')x $args{len};print "\r$spaces\r"}}sub get_branch_range {my ($start,$end)=@_;return$end ? "$start..$end" : $start}sub get_rev_list {my$self=shift;my ($start,$end)=@_;my$refspec=get_branch_range($start,$end);my@cmd_rev_list=('git rev-list --no-merges',$refspec);my$cmd=join ' ',@cmd_rev_list;my ($stdout,$stderr,$exit_status)=App::Task::Base->system_call($cmd,ignore_exit_status=>1,);my@rev_list=split "\n",$stdout;return@rev_list}sub get_remote_branch_for_env {my ($self,$env,$task_branch_name)=@_;my ($target_branch_name,$remote);my$final_env=$env;if ($env =~ /^ready for (\w+)/){$target_branch_name=$task_branch_name;$final_env=$1;if ($final_env eq 'integration'){$remote='origin'}else {$remote="origin/$final_env-ready"}}elsif ($env eq 'Un-merged changes'){$target_branch_name=$task_branch_name;$remote=''}else {$target_branch_name=App::Task::Base->environments->{$final_env}{branch_name};$remote="origin"}if ($target_branch_name eq 'master'){$target_branch_name=App::Task::Base->environments->{$final_env}{branch_name}}return ($target_branch_name,$remote)}sub print_git_command {my$self=shift;my ($cmd)=@_;my ($output,$error,$exit_status)=App::Task::Base->system_call($cmd);my@lines=split(/\n/,$output);if ($cmd =~ /--stat\b/){if (grep {$_ =~ m{ \.\.\./}}@lines){push@lines,$self->print_color(['black']," (specify --name-only to see full file names)")}}$self->print_indented($_)for@lines;print "\n";return [$output,$error,$exit_status]}sub get_indented_screen_width {my$self=shift;return unless$self->columns;return$self->columns - $self->indent}sub make_git_stat_cmd {my$self=shift;my$w=$self->get_indented_screen_width;return '--stat' unless$w;return "--stat=$w,$w"}sub print_color {my$self=shift;my ($color_list,$string)=@_;if ($self->args->{color}){return colored($color_list,$string)}else {return$string}}sub run {my ($self)=@_;if (my$branch=$self->task_branch){my$task_branch_name=$self->content_tracker->get_branch_name($branch);my@deployment_branches=$self->content_tracker->get_all_deployment_branches($branch);for my$branch_name ($task_branch_name,@deployment_branches){my%status=$self->get_status($branch_name);$self->print_status_info(branch=>$branch_name,status=>\%status,)}}}sub print_status_info {my$self=shift;my%args=@_;my$task_branch_name=$args{branch};die "branch not specified" if!$args{branch};die "status not specified" if!$args{status};my$git_args=$self->args->{color}? '--color' : '';$self->print_indented($self->print_color(['bold'],"Deployment status for $task_branch_name:\n"));$self->increase_indent;my@envs=@{$self->ordered_envs};my$prev_env;for my$env (@envs){my%env_commits=%{$args{status}->{env_commits}->{$env}};my$commit_key='rel_commits';my@commits=@{$env_commits{$commit_key}->{list}|| []};if (!scalar@commits || $env_commits{same_as_prev_env}){$prev_env=$env;next}my$commit_last=$env_commits{branch_tip};my$commit_first;if ($prev_env && $commit_key eq 'rel_commits'){$commit_first=$args{status}{env_commits}{$prev_env}{branch_tip}}$commit_first ||=$env_commits{branch_start_ref};my$commit_range="$commit_first..$commit_last";$self->print_env_label($env);$self->increase_indent;if ($self->args->{log}){my@log_args=('--no-merges');push@log_args,$self->make_git_stat_cmd();push@log_args,'-p' if$self->args->{diff};push@log_args,'--name-only' if$self->args->{name_only};$self->print_git_command(sprintf("git log $git_args %s %s %s",defined$self->args->{log_options}? $self->args->{log_options}: '',join(' ',@log_args),$commit_range))}else {my$l=$self->print_color(['blue'],"Branch tip:  ");my$c=$self->print_color(['yellow'],$commit_last);$self->print_indented("$l $c");my$short_range=$commit_first eq $commit_last ? substr($commit_first,0,7): substr($commit_first,0,7).'..' .substr($commit_last,0,7);$self->print_indented(sprintf("%s %s (%d commit%s)",$self->print_color(['blue'],"Commit range:"),$self->print_color(['yellow'],"$short_range"),scalar@commits,scalar@commits==1 ? '' : 's',));if ($self->args->{all_commits}){$self->print_indented($self->print_color(['blue'],"All commits:"));$self->increase_indent;for my$commit (@commits){$self->print_indented($self->print_color(['yellow'],$commit))}$self->decrease_indent}print "\n";my@diff_args;push@diff_args,'--name-only' if$self->args->{name_only};push@diff_args,$self->make_git_stat_cmd();push@diff_args,sprintf('-p %s',(defined$self->args->{diff_options}? $self->args->{diff_options}: ''))if$self->args->{diff};$self->print_git_command(sprintf("git diff $git_args %s %s",join(' ',@diff_args),$commit_range,))}$self->decrease_indent;$prev_env=$env}$self->decrease_indent}sub print_env_label {my$self=shift;my ($env)=@_;my$env_label="$env" ;$self->print_indented($self->print_color(['bold green'],"$env_label:"));if ($self->args->{log}|| $self->args->{diff}){$self->print_indented($self->print_color(['bold green'],'-' x ($self->get_indented_screen_width || 80)))}}sub abort {my ($self,$message)=@_;print color 'red';print "$message\n";print color 'reset';exit}no Moo;no Types::Standard;sub usage {my ($self,$message)=@_;print "$message\n\n" if$message;print <<"END_USAGE";exit 1}1;
  Usage: task status [-h] <branch_name>
  
  Get info about which environments files for a task have been pushed to. Checks
  the status of the current task branch if none is specified.
  
  The most current version of the file (on HEAD) always shows up in bold.
  
  Options:
  
      -h, --help               Show a brief help message and exit
      --all-commits            Print a list of commits affected for each
                               environment, rather than just the commit range. This
                               gives a complete list of commits, without the
                               verbosity of --log.
      -c, --color, --colour    Enable colored output. On by default. Off when the
                               terminal isn't interactive, but can be forced by
                               manually setting --color.
      --diff-options <options> Specifies extra options to pass to `git diff` when
                               -p or --diff are used.
      -l, --log                Print `git log` information for each environment.
                               Can be used with --stat and -p or --diff to print
                               stat and diff information for each log entry.
      --log-options <options>  Specifies extra options to pass to `git log` when
                               --log is used.
      --name-only              Print a list of files affected for each environment,
                               without the verbosity of --stat. Can also be used if
                               the files affected printed by --stat are
                               abbreviated, since --name-only will not abbreviate
                               file names.
      -p, --diff               Print `git diff` information for each environment.
                               This will show diffs for entire environments, or
                               per log entry if used with --log.
  END_USAGE
APP_TASK_COMMAND_STATUS

$fatpacked{"App/Task/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_CONFIG';
  package App::Task::Config;use strict;use warnings;use YAML qw(LoadFile);my (%commands,%config_data);our%options;sub register_command {my ($module,$name,$description)=@_;if ($module eq __PACKAGE__){($module)=caller}$commands{$name}={description=>$description,module=>$module,}}sub command_list {return sort keys%commands}sub find_command {my ($package,$name)=@_;return$commands{$name}}sub get_option {my ($package,$option_name)=@_;return$options{$option_name}}sub set_option {my ($package,$option_name,$value)=@_;$options{$option_name}=$value}sub configure {my ($package,$config_file)=@_;undef%config_data;my ($relative_to_root)=`git rev-parse --show-cdup`;chomp$relative_to_root;if (!$config_file){$config_file=($relative_to_root ? "$relative_to_root/" : '').'deployment.yaml'}if (-e $config_file && -r $config_file){my$repo_config=LoadFile$config_file or die "Couldn't load config file '$config_file";$config_data{environments}=$repo_config->{environments};$config_data{mainline_branch}=$repo_config->{mainline_branch}|| 'master';$config_data{github_url}=$repo_config->{github_url};$config_data{hooks}=$repo_config->{hooks}}else {return "Can't read config file: $config_file"}$config_data{repo_root}=$relative_to_root || ".";for my$env (keys %{$config_data{environments}}){$config_data{environments}{$env}{name}=$env}return}sub config {return \%config_data}1;
APP_TASK_CONFIG

$fatpacked{"App/Task/ContentTracker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_CONTENTTRACKER';
  package App::Task::ContentTracker;use Moo;use File::Spec::Functions qw(rel2abs abs2rel);use Cwd qw(getcwd);use Term::ANSIColor;use IO::Interactive qw(is_interactive);has 'current_branch'=>(is=>'rw',lazy=>1,builder=>'_build_current_branch',clearer=>'_clear_current_branch',);has 'all_branches'=>(is=>'ro',lazy=>1,builder=>'_build_all_branches',clearer=>'_clear_all_branches',);no Moo;sub get_repository_root {my ($abs_top_level_dir)=App::Task::Base->system_call("git rev-parse --show-toplevel");chomp$abs_top_level_dir;return$abs_top_level_dir}sub create_deployment_branch {my ($self,$branch)=@_;my$task_branch_name=$self->get_branch_name($branch);my$deployment_branch_name=$self->get_next_deployment_branch_name($branch);my$mainline_branch=App::Task::Config->config->{mainline_branch};my ($merge_commit)=App::Task::Base->system_call("git merge-base $task_branch_name $mainline_branch",ignore_exit_status=>1);$self->_create_branch($deployment_branch_name,$merge_commit);return$deployment_branch_name}sub _create_branch {my ($self,$branch_name,$start_ref)=@_;my$mainline_branch=App::Task::Config->config->{mainline_branch};my@branches=@{$self->all_branches};if (!$start_ref){if (scalar grep {/^remotes\/origin\/$mainline_branch/ims}@branches){$start_ref="origin/$mainline_branch"}else {$start_ref=$mainline_branch}}my$original_branch=$self->get_current_branch;my$current_dir=getcwd;if (scalar grep {/^\Q$branch_name/i}@branches){my ($output)=App::Task::Base->system_call("git checkout $branch_name",combine=>1);print$output}elsif (scalar grep {/^remotes\/origin\/\Q$branch_name\E$/i}@branches){my ($output)=App::Task::Base->system_call("git checkout --track -b $branch_name origin/$branch_name");print$output}else {App::Task::Base->system_call("git checkout --no-track -b $branch_name $start_ref");print "Created and switched to branch '$branch_name' from $start_ref\n";if ($start_ref eq "origin/$mainline_branch"){App::Task::Base->system_call("git branch --set-upstream $branch_name $start_ref")}}$self->_clear_all_branches;$self->current_branch($branch_name);return$branch_name}sub add_files_to_new_deployment_branch {my ($self,$branch,$files)=@_;die "No branch specified to add files to" if!$branch;my$original_branch=$self->get_current_branch;my$current_dir=getcwd;my$branch_name=$self->create_deployment_branch($branch);$self->_add_files_to_branch(source_branch=>$original_branch,target_branch=>$branch_name,current_dir=>$current_dir,files=>$files,);return$branch_name}sub _add_files_to_branch {my ($self,%args)=@_;my$original_branch=$args{source_branch}or die 'no target branch';my$branch_name=$args{target_branch}or die 'no target branch';my$current_dir=$args{current_dir}|| getcwd;my@files=@{$args{files}|| []};chdir$self->get_repository_root;my$file_list=join(' ',map {"'$_'"}@files);App::Task::Base->system_call("git checkout $original_branch $file_list");App::Task::Base->system_call("git commit -n -m \"Added files: $file_list to branch $branch_name from branch $original_branch\"",ignore_exit_status=>1);App::Task::Base->system_call("git checkout $original_branch");chdir$current_dir;if ($original_branch ne $branch_name){print "Added the following " .(scalar(@files)==1 ? 'file' : 'files')." from branch '$original_branch' into branch '$branch_name': $file_list\n"}else {print((scalar(@files)==1 ? 'File is' : 'Files are')." already in branch '$branch_name': $file_list\n")}}sub get_deployed_envs {my ($self,$branch_name)=@_;my ($remote_branches)=App::Task::Base->system_call("git branch -r --contains $branch_name");my%env_names=map {$_=>1}keys %{App::Task::Base->environments};my%deployed_envs;for my$raw_branch (split("\n",$remote_branches)){my ($remote)=$raw_branch =~ / *\*? *origin\/(\w+)$/;next if!$remote;next if!exists$env_names{$remote};$deployed_envs{$remote}=1}return \%deployed_envs}sub get_current_branch {my ($self)=@_;return$self->current_branch}sub _build_current_branch {my ($self)=@_;my ($branches)=App::Task::Base->system_call("git branch");my ($current_branch)=$branches =~ /^\* ([^\n]+)/ims;return$current_branch}sub _build_all_branches {my ($self)=@_;my ($branches)=App::Task::Base->system_call("git branch -a");my@branches;for my$branch (split /^/,$branches){chomp$branch;$branch =~ s/^(\*?)[ \t]*(.*)[ \t]*$/$2/;$self->current_branch($branch)if $1;push@branches,$branch}return \@branches}sub unique_branches {my ($self)=@_;my (%branches,@branches);for my$branch (@{$self->all_branches}){my$non_origin_branch=$branch;$non_origin_branch =~ s/^remotes\/origin\///;next if exists$branches{$non_origin_branch};$branches{$non_origin_branch}=1;push@branches,$non_origin_branch}return \@branches}sub get_branches_by_prefix {my ($self,$prefix)=@_;my@branches=@{$self->unique_branches};my@matches=grep {/^\Q$prefix/}@branches;return@matches}sub get_branch_name {my ($self,$branch)=@_;if ($branch){my@existing_branches_matching=$self->get_branches_by_prefix($branch);if (grep {$_ eq $branch}@existing_branches_matching){return$branch}@existing_branches_matching=grep {!/[\/-]deploy\d+$/}@existing_branches_matching;if (@existing_branches_matching > 1){die "Ambiguous branch specified $branch:\n",join("\n",map "  $_",@existing_branches_matching)}if (@existing_branches_matching){return$existing_branches_matching[0]}return$branch}else {return$self->get_current_branch}}sub get_next_deployment_branch_name {my ($self,$branch)=@_;my@existing=$self->get_all_deployment_branches($branch);my$deployment_branch_count=0;for my$branch_name (@existing){if ($branch_name =~ /[\/-]deploy(\d+)$/i){$deployment_branch_count=$1 if $1 > $deployment_branch_count}}return "$branch-deploy" .($deployment_branch_count + 1)}sub get_all_deployment_branches {my ($self,$branch)=@_;my@branches=@{$self->unique_branches};my%deployment_branches;for my$branch_name (@branches){if ($branch_name =~ /^($branch[\/-]deploy(\d+))/ims){$deployment_branches{$2}=$1}}return map {$deployment_branches{$_}}sort {$a <=> $b}keys%deployment_branches}sub get_changed_files {my ($self,$branch,$commit_id,%options)=@_;my$branch_name;if ($options{branch_name}){$branch_name=$options{branch_name}}else {$branch_name=$self->get_branch_name($branch)}my ($file_list,$error,$exit_status)=App::Task::Base->system_call("git diff --name-only \$(git merge-base $branch_name $commit_id) $branch_name",ignore_exit_status=>1);chomp$file_list;my@files=map {s/^\s*|\s*$//ms;$_}split(/\n/,$file_list);return@files}sub safe_merge {my ($self,$merge_branch_name,$env_name,$target_branch,$options,$action)=@_;my$target_branch_name=App::Task::Base->environments->{$env_name}{branch_name};my ($merge_output,$merge_errors,$exit_status)=App::Task::Base->system_call("git merge $options $merge_branch_name",ignore_exit_status=>1);if ($exit_status){my@bad_files=$self->get_conflicted_files;my$remote_task_branch_exclude='';if ($action eq 're-ready'){print "merging local branch $merge_branch_name into $env_name/$merge_branch_name failed\n";$remote_task_branch_exclude=" ^$target_branch"}elsif ($action eq 'ready'){print "merging local branch $merge_branch_name into origin/$target_branch_name to create $merge_branch_name on $env_name failed\n"}elsif ($action eq 'deploy'){print "merging local branch $merge_branch_name into origin/$target_branch_name failed\n"}else {print "merging local branch $merge_branch_name into $target_branch failed\n"}print "See the entire problem through 'git diff ^origin/$target_branch_name$remote_task_branch_exclude $merge_branch_name'\n";print "This probably means that another task that has been pushed to $env_name conflicts with branch $merge_branch_name. 'git blame' on conflicting files and git branch -r contains <commit_id> for lines with conflicts, should give you enough information to find out which task branch is conflicting. It is recommended to add one branch to the other and make one dependent on the other to make it so you won't have to fix conflicts at every environment deploy\n\n";print "-----------------\n\n";print `git diff`;print "\n\nHow do you want to resolve this conflict?\n";my$response=App::Task::Base->prompt(s=>'open a shell to fix the merge manually',default=>'reset',);eval {if ($response =~ /open a shell/i){print "Fix your conflict and commit\n";print "Exit shell to finish the deployment\n";system('bash')}else {die "Exiting"}my@remaining_bad_files=$self->get_conflicted_files;if (@remaining_bad_files){die "You didn't fix: @remaining_bad_files\n"}print "conflicts resolved\n"};if ($@){print "Resetting merge...\n";App::Task::Base->system_call("git reset --merge");die color('red')."Can't continue after a failed merge to environment: $env_name\n$@\n" .color('reset')}}}sub get_conflicted_files {my$self=shift;my$output=`git status -s`;chomp$output;my@files=split("\n",$output);my$relative_to_root=`git rev-parse --show-cdup`;chomp$relative_to_root;my@conflicted_files;for my$file (@files){if (my ($path)=$file =~ /^ *U\w+ *(.*)/){push@conflicted_files,"$relative_to_root$path"}}return@conflicted_files}sub update_remotes {my ($self)=@_;if (App::Task::Config->get_option('needs-update')){my$msg="Updating remote git repositories...";print$msg if is_interactive();App::Task::Base->system_call("git remote update --prune");printf("\r%s\r",' ' x length($msg))if is_interactive();App::Task::Config->set_option('needs-update'=>0)}}1;
APP_TASK_CONTENTTRACKER

$fatpacked{"App/Task/Hooks.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TASK_HOOKS';
  package App::Task::Hooks;use Moo;use App::Task::Config;sub default_env {my$config=App::Task::Config->config;return (TASK_REPO_ROOT=>$config->{repo_root},)}sub find_hooks {my ($self,$command,$hook_name)=@_;my@hooks;my$hooks=$command->env->{hooks};if ($hooks && $hooks->{$hook_name}){push@hooks,@{$hooks->{$hook_name}}}my$global_hooks=App::Task::Config->config->{hooks};if ($global_hooks && $global_hooks->{$hook_name}){push@hooks,@{$global_hooks->{$hook_name}}}return@hooks}sub run_hooks {my ($self,$command,$hook_name,$env)=@_;my@hooks=$self->find_hooks($command,$hook_name);{local%ENV=(%ENV,$self->default_env,%{$env || {}},);for my$hook (@hooks){my$ok=$self->run_hook($command,$hook_name,$hook);if (!$ok){return}}}return 1}sub run_hook {my ($self,$command,$hook_name,$hook)=@_;my$root=App::Task::Config->config->{repo_root};my$hook_path="$root/$hook";my$prelude="Hook '$hook_path' for $hook_name";if (!-e $hook_path){warn "$prelude doesn't exist, skipping";return 1}if (!-x $hook_path){warn "$prelude isn't executable, skipping";return 1}my$system_ret=system($hook_path);if ($system_ret){if ($?==-1){warn "$prelude couldn't be executed: $!"}elsif ($? & 127){warn "$prelude exited with signal ",($? & 127)}else {warn "$prelude exited with nonzero status ",$? >> 8}return 0}else {return 1}}1;
APP_TASK_HOOKS

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;use strictures 1;use Moo::_Utils;use base qw(Moo::Object);use Sub::Quote;use B 'perlstring';use Scalar::Util 'blessed';use overload ();use Module::Runtime qw(use_module);BEGIN {our$CAN_HAZ_XS=!$ENV{MOO_XS_DISABLE}&& _maybe_load_module('Class::XSAccessor')&& (eval {Class::XSAccessor->VERSION('1.07')})}sub _SIGDIE {our ($CurrentAttribute,$OrigSigDie);my$sigdie=$OrigSigDie && $OrigSigDie!=\&_SIGDIE ? $OrigSigDie : sub {die $_[0]};return$sigdie->(@_)if ref($_[0]);my$attr_desc=_attr_desc(@$CurrentAttribute{qw(name init_arg)});$sigdie->("$CurrentAttribute->{step} for $attr_desc failed: $_[0]")}sub _die_overwrite {my ($pkg,$method,$type)=@_;die "You cannot overwrite a locally defined method ($method) with @{[ $type || 'an accessor' ]}"}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;$spec->{allow_overwrite}++ if$name =~ s/^\+//;die "Must have an is" unless my$is=$spec->{is};if ($is eq 'ro'){$spec->{reader}=$name unless exists$spec->{reader}}elsif ($is eq 'rw'){$spec->{accessor}=$name unless exists$spec->{accessor}or ($spec->{reader}and $spec->{writer})}elsif ($is eq 'lazy'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{lazy}=1;$spec->{builder}||='_build_'.$name unless$spec->{default}}elsif ($is eq 'rwp'){$spec->{reader}=$name unless exists$spec->{reader};$spec->{writer}="_set_${name}" unless exists$spec->{writer}}elsif ($is ne 'bare'){die "Unknown is ${is}"}if (exists$spec->{builder}){if(ref$spec->{builder}){$self->_validate_codulatable('builder',$spec->{builder},"$into->$name",'or a method name');$spec->{builder_sub}=$spec->{builder};$spec->{builder}=1}$spec->{builder}='_build_'.$name if ($spec->{builder}||0)eq 1;die "Invalid builder for $into->$name - not a valid method name" if$spec->{builder}!~ /\A[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)*\z/}if (($spec->{predicate}||0)eq 1){$spec->{predicate}=$name =~ /^_/ ? "_has${name}" : "has_${name}"}if (($spec->{clearer}||0)eq 1){$spec->{clearer}=$name =~ /^_/ ? "_clear${name}" : "clear_${name}"}if (($spec->{trigger}||0)eq 1){$spec->{trigger}=quote_sub('shift->_trigger_'.$name.'(@_)')}for my$setting (qw(isa coerce)){next if!exists$spec->{$setting};$self->_validate_codulatable($setting,$spec->{$setting},"$into->$name")}if (exists$spec->{default}){if (!defined$spec->{default}|| ref$spec->{default}){$self->_validate_codulatable('default',$spec->{default},"$into->$name",'or a non-ref')}}if (exists$spec->{moosify}){if (ref$spec->{moosify}ne 'ARRAY'){$spec->{moosify}=[$spec->{moosify}]}for my$spec (@{$spec->{moosify}}){$self->_validate_codulatable('moosify',$spec,"$into->$name")}}my%methods;if (my$reader=$spec->{reader}){_die_overwrite($into,$reader,'a reader')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${reader}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)){$methods{$reader}=$self->_generate_xs(getters=>$into,$reader,$name,$spec)}else {$self->{captures}={};$methods{$reader}=quote_sub "${into}::${reader}" =>'    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n" .$self->_generate_get($name,$spec)=>delete$self->{captures}}}if (my$accessor=$spec->{accessor}){_die_overwrite($into,$accessor,'an accessor')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${accessor}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_get($name,$spec)&& $self->is_simple_set($name,$spec)){$methods{$accessor}=$self->_generate_xs(accessors=>$into,$accessor,$name,$spec)}else {$self->{captures}={};$methods{$accessor}=quote_sub "${into}::${accessor}" =>$self->_generate_getset($name,$spec)=>delete$self->{captures}}}if (my$writer=$spec->{writer}){_die_overwrite($into,$writer,'a writer')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${writer}")}{CODE};if (our$CAN_HAZ_XS && $self->is_simple_set($name,$spec)){$methods{$writer}=$self->_generate_xs(setters=>$into,$writer,$name,$spec)}else {$self->{captures}={};$methods{$writer}=quote_sub "${into}::${writer}" =>$self->_generate_set($name,$spec)=>delete$self->{captures}}}if (my$pred=$spec->{predicate}){_die_overwrite($into,$pred,'a predicate')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${pred}")}{CODE};$methods{$pred}=quote_sub "${into}::${pred}"=>'    '.$self->_generate_simple_has('$_[0]',$name,$spec)."\n" }if (my$pred=$spec->{builder_sub}){_install_coderef("${into}::$spec->{builder}"=>$spec->{builder_sub})}if (my$cl=$spec->{clearer}){_die_overwrite($into,$cl,'a clearer')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${cl}")}{CODE};$methods{$cl}=quote_sub "${into}::${cl}"=>$self->_generate_simple_clear('$_[0]',$name,$spec)."\n" }if (my$hspec=$spec->{handles}){my$asserter=$spec->{asserter}||='_assert_'.$name;my@specs=do {if (ref($hspec)eq 'ARRAY'){map [$_=>$_ ],@$hspec}elsif (ref($hspec)eq 'HASH'){map [$_=>ref($hspec->{$_})? @{$hspec->{$_}}: $hspec->{$_}],keys %$hspec}elsif (!ref($hspec)){map [$_=>$_ ],use_module('Role::Tiny')->methods_provided_by(use_module($hspec))}else {die "You gave me a handles of ${hspec} and I have no idea why"}};for my$delegation_spec (@specs){my ($proxy,$target,@args)=@$delegation_spec;_die_overwrite($into,$proxy,'a delegation')if!$spec->{allow_overwrite}&& *{_getglob("${into}::${proxy}")}{CODE};$self->{captures}={};$methods{$proxy}=quote_sub "${into}::${proxy}"=>$self->_generate_delegation($asserter,$target,\@args),delete$self->{captures}}}if (my$asserter=$spec->{asserter}){$self->{captures}={};$methods{$asserter}=quote_sub "${into}::${asserter}"=>$self->_generate_asserter($name,$spec),delete$self->{captures}}\%methods}sub is_simple_attribute {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(lazy default builder coerce isa trigger predicate weak_ref)}sub is_simple_get {my ($self,$name,$spec)=@_;!($spec->{lazy}and ($spec->{default}or $spec->{builder}))}sub is_simple_set {my ($self,$name,$spec)=@_;!grep$spec->{$_},qw(coerce isa trigger weak_ref)}sub has_eager_default {my ($self,$name,$spec)=@_;(!$spec->{lazy}and (exists$spec->{default}or $spec->{builder}))}sub _generate_get {my ($self,$name,$spec)=@_;my$simple=$self->_generate_simple_get('$_[0]',$name,$spec);if ($self->is_simple_get($name,$spec)){$simple}else {$self->_generate_use_default('$_[0]',$name,$spec,$self->_generate_simple_has('$_[0]',$name,$spec),)}}sub generate_simple_has {my$self=shift;$self->{captures}={};my$code=$self->_generate_simple_has(@_);($code,delete$self->{captures})}sub _generate_simple_has {my ($self,$me,$name)=@_;"exists ${me}->{${\perlstring $name}}"}sub _generate_simple_clear {my ($self,$me,$name)=@_;"    delete ${me}->{${\perlstring $name}}\n"}sub generate_get_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_get_default(@_);($code,delete$self->{captures})}sub generate_use_default {my$self=shift;$self->{captures}={};my$code=$self->_generate_use_default(@_);($code,delete$self->{captures})}sub _generate_use_default {my ($self,$me,$name,$spec,$test)=@_;my$get_value=$self->_generate_get_default($me,$name,$spec);if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce})}$test." ? \n" .$self->_generate_simple_get($me,$name,$spec)."\n:" .($spec->{isa}? "    do {\n      my \$value = ".$get_value.";\n" ."      ".$self->_generate_isa_check($name,'$value',$spec->{isa}).";\n" ."      ".$self->_generate_simple_set($me,$name,$spec,'$value')."\n" ."    }\n" : '    ('.$self->_generate_simple_set($me,$name,$spec,$get_value).")\n")}sub _generate_get_default {my ($self,$me,$name,$spec)=@_;if (exists$spec->{default}){ref$spec->{default}? $self->_generate_call_code($name,'default',$me,$spec->{default}): perlstring$spec->{default}}else {"${me}->${\$spec->{builder}}"}}sub generate_simple_get {my ($self,@args)=@_;$self->_generate_simple_get(@args)}sub _generate_simple_get {my ($self,$me,$name)=@_;my$name_str=perlstring$name;"${me}->{${name_str}}"}sub _generate_set {my ($self,$name,$spec)=@_;if ($self->is_simple_set($name,$spec)){$self->_generate_simple_set('$_[0]',$name,$spec,'$_[1]')}else {my ($coerce,$trigger,$isa_check)=@{$spec}{qw(coerce trigger isa)};my$value_store='$_[0]';my$code;if ($coerce){$value_store='$value';$code="do { my (\$self, \$value) = \@_;\n" ."        \$value = " .$self->_generate_coerce($name,$value_store,$coerce).";\n"}else {$code="do { my \$self = shift;\n"}if ($isa_check){$code .= "        ".$self->_generate_isa_check($name,$value_store,$isa_check).";\n"}my$simple=$self->_generate_simple_set('$self',$name,$spec,$value_store);if ($trigger){my$fire=$self->_generate_trigger($name,'$self',$value_store,$trigger);$code .= "        ".$simple.";\n        ".$fire.";\n" ."        $value_store;\n"}else {$code .= "        ".$simple.";\n"}$code .= "      }";$code}}sub generate_coerce {my$self=shift;$self->{captures}={};my$code=$self->_generate_coerce(@_);($code,delete$self->{captures})}sub _attr_desc {my ($name,$init_arg)=@_;return perlstring($name)if!defined($init_arg)or $init_arg eq $name;return perlstring($name).' (constructor argument: '.perlstring($init_arg).')'}sub _generate_coerce {my ($self,$name,$value,$coerce,$init_arg)=@_;$self->_generate_die_prefix($name,"coercion",$init_arg,$self->_generate_call_code($name,'coerce',"${value}",$coerce))}sub generate_trigger {my$self=shift;$self->{captures}={};my$code=$self->_generate_trigger(@_);($code,delete$self->{captures})}sub _generate_trigger {my ($self,$name,$obj,$value,$trigger)=@_;$self->_generate_call_code($name,'trigger',"${obj}, ${value}",$trigger)}sub generate_isa_check {my ($self,@args)=@_;$self->{captures}={};my$code=$self->_generate_isa_check(@args);($code,delete$self->{captures})}sub _generate_die_prefix {my ($self,$name,$prefix,$arg,$inside)=@_;"do {\n" .'  local $Method::Generate::Accessor::CurrentAttribute = {' .'    init_arg => '.(defined$arg ? B::perlstring($arg): 'undef').",\n" .'    name     => '.B::perlstring($name).",\n" .'    step     => '.B::perlstring($prefix).",\n" ."  };\n" .'  local $Method::Generate::Accessor::OrigSigDie = $SIG{__DIE__};'."\n" .'  local $SIG{__DIE__} = \&Method::Generate::Accessor::_SIGDIE;'."\n" .$inside ."}\n"}sub _generate_isa_check {my ($self,$name,$value,$check,$init_arg)=@_;$self->_generate_die_prefix($name,"isa check",$init_arg,$self->_generate_call_code($name,'isa_check',$value,$check))}sub _generate_call_code {my ($self,$name,$type,$values,$sub)=@_;$sub=\&{$sub}if blessed($sub);if (my$quoted=quoted_from_sub($sub)){my$local=1;if ($values eq '@_' || $values eq '$_[0]'){$local=0;$values='@_'}my$code=$quoted->[1];if (my$captures=$quoted->[2]){my$cap_name=qq{\$${type}_captures_for_${name}};$self->{captures}->{$cap_name}=\$captures;Sub::Quote::inlinify($code,$values,Sub::Quote::capture_unroll($cap_name,$captures,6),$local)}else {Sub::Quote::inlinify($code,$values,undef,$local)}}else {my$cap_name=qq{\$${type}_for_${name}};$self->{captures}->{$cap_name}=\$sub;"${cap_name}->(${values})"}}sub generate_populate_set {my$self=shift;$self->{captures}={};my$code=$self->_generate_populate_set(@_);($code,delete$self->{captures})}sub _generate_populate_set {my ($self,$me,$name,$spec,$source,$test,$init_arg)=@_;if ($self->has_eager_default($name,$spec)){my$get_indent=' ' x ($spec->{isa}? 6 : 4);my$get_default=$self->_generate_get_default('$new',$name,$spec);my$get_value=defined($spec->{init_arg})? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : " .$get_default ."\n${get_indent})" : $get_default;if ($spec->{coerce}){$get_value=$self->_generate_coerce($name,$get_value,$spec->{coerce},$init_arg)}($spec->{isa}? "    {\n      my \$value = ".$get_value.";\n      " .$self->_generate_isa_check($name,'$value',$spec->{isa},$init_arg).";\n" .'      '.$self->_generate_simple_set($me,$name,$spec,'$value').";\n" ."    }\n" : '    '.$self->_generate_simple_set($me,$name,$spec,$get_value).";\n").($spec->{trigger}? '    ' .$self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger})." if ${test};\n" : '')}else {"    if (${test}) {\n" .($spec->{coerce}? "      $source = " .$self->_generate_coerce($name,$source,$spec->{coerce},$init_arg).";\n" : "").($spec->{isa}? "      " .$self->_generate_isa_check($name,$source,$spec->{isa},$init_arg).";\n" : "")."      ".$self->_generate_simple_set($me,$name,$spec,$source).";\n" .($spec->{trigger}? "      " .$self->_generate_trigger($name,$me,$self->_generate_simple_get($me,$name,$spec),$spec->{trigger}).";\n" : "")."    }\n"}}sub _generate_core_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=perlstring$name;"${me}->{${name_str}} = ${value}"}sub _generate_simple_set {my ($self,$me,$name,$spec,$value)=@_;my$name_str=perlstring$name;my$simple=$self->_generate_core_set($me,$name,$spec,$value);if ($spec->{weak_ref}){require Scalar::Util;my$get=$self->_generate_simple_get($me,$name,$spec);my$weak_simple="do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";Moo::_Utils::lt_5_8_3()? <<"EOC" : $weak_simple}else {$simple}}sub _generate_getset {my ($self,$name,$spec)=@_;q{(@_ > 1}."\n      ? ".$self->_generate_set($name,$spec)."\n      : ".$self->_generate_get($name,$spec)."\n    )"}sub _generate_asserter {my ($self,$name,$spec)=@_;"do {\n" ."  my \$val = ".$self->_generate_get($name,$spec).";\n" ."  unless (".$self->_generate_simple_has('$_[0]',$name,$spec).") {\n" .qq!    die "Attempted to access '${name}' but it is not set";\n! ."  }\n" ."  \$val;\n" ."}\n"}sub _generate_delegation {my ($self,$asserter,$target,$args)=@_;my$arg_string=do {if (@$args){$self->{captures}{'@curries'}=$args;'@curries, @_'}else {'@_'}};"shift->${asserter}->${target}(${arg_string});"}sub _generate_xs {my ($self,$type,$into,$name,$slot)=@_;Class::XSAccessor->import(class=>$into,$type=>{$name=>$slot },replace=>1,);$into->can($name)}sub default_construction_string {'{}'}sub _validate_codulatable {my ($self,$setting,$value,$into,$appended)=@_;my$invalid="Invalid $setting '" .overload::StrVal($value)."' for $into not a coderef";$invalid .= " $appended" if$appended;unless (ref$value and (ref$value eq 'CODE' or blessed($value))){die "$invalid or code-convertible object"}unless (eval {\&$value}){die "$invalid and could not be converted to a coderef: $@"}1}1;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;use strictures 1;use base qw(Moo::Object);use Sub::Quote;use Moo::_Utils;use B 'perlstring';sub generate_method {my ($self,$into)=@_;quote_sub "${into}::BUILDALL",join '',$self->_handle_subbuild($into),qq{    my \$self = shift;\n},$self->buildall_body_for($into,'$self','@_'),qq{    return \$self\n}}sub _handle_subbuild {my ($self,$into)=@_;'    if (ref($_[0]) ne '.perlstring($into).') {'."\n".'      return shift->Moo::Object::BUILDALL(@_)'.";\n".'    }'."\n"}sub buildall_body_for {my ($self,$into,$me,$args)=@_;my@builds=grep *{_getglob($_)}{CODE},map "${_}::BUILD",reverse @{Moo::_Utils::_get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@builds}1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;use strictures 1;use Sub::Quote;use base qw(Moo::Object);use Sub::Defer;use B 'perlstring';use Moo::_Utils qw(_getstash);sub register_attribute_specs {my ($self,@new_specs)=@_;my$specs=$self->{attribute_specs}||={};while (my ($name,$new_spec)=splice@new_specs,0,2){if ($name =~ s/^\+//){die "has '+${name}' given but no ${name} attribute already exists" unless my$old_spec=$specs->{$name};for my$key (keys %$old_spec){if (!exists$new_spec->{$key}){$new_spec->{$key}=$old_spec->{$key}unless$key eq 'handles'}elsif ($key eq 'moosify'){$new_spec->{$key}=[map {ref $_ eq 'ARRAY' ? @$_ : $_}($old_spec->{$key},$new_spec->{$key})]}}}$new_spec->{index}=scalar keys %$specs unless defined$new_spec->{index};$specs->{$name}=$new_spec}$self}sub all_attribute_specs {$_[0]->{attribute_specs}}sub accessor_generator {$_[0]->{accessor_generator}}sub construction_string {my ($self)=@_;$self->{construction_string}||=$self->_build_construction_string}sub _build_construction_string {'bless(' .$_[0]->accessor_generator->default_construction_string .', $class);'}sub install_delayed {my ($self)=@_;my$package=$self->{package};defer_sub "${package}::new"=>sub {unquote_sub$self->generate_method($package,'new',$self->{attribute_specs},{no_install=>1 })};$self}sub generate_method {my ($self,$into,$name,$spec,$quote_opts)=@_;for my$no_init (grep!exists($spec->{$_}{init_arg}),keys %$spec){$spec->{$no_init}{init_arg}=$no_init}local$self->{captures}={};my$body='    my $class = shift;'."\n" .'    $class = ref($class) if ref($class);'."\n";$body .= $self->_handle_subconstructor($into,$name);my$into_buildargs=$into->can('BUILDARGS');if ($into_buildargs && $into_buildargs!=\&Moo::Object::BUILDARGS){$body .= $self->_generate_args_via_buildargs}else {$body .= $self->_generate_args}$body .= $self->_check_required($spec);$body .= '    my $new = '.$self->construction_string.";\n";$body .= $self->_assign_new($spec);if ($into->can('BUILD')){require Method::Generate::BuildAll;$body .= Method::Generate::BuildAll->new->buildall_body_for($into,'$new','$args')}$body .= '    return $new;'."\n";if ($into->can('DEMOLISH')){require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new->generate_method($into)}quote_sub "${into}::${name}"=>$body,$self->{captures},$quote_opts||{}}sub _handle_subconstructor {my ($self,$into,$name)=@_;if (my$gen=$self->{subconstructor_handler}){'    if ($class ne '.perlstring($into).') {'."\n".$gen.'    }'."\n"}else {''}}sub _cap_call {my ($self,$code,$captures)=@_;@{$self->{captures}}{keys %$captures}=values %$captures if$captures;$code}sub _generate_args_via_buildargs {my ($self)=@_;q{    my $args = $class->BUILDARGS(@_);}."\n" .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';} ."\n"}sub _generate_args {my ($self)=@_;return <<'_EOA'}sub _assign_new {my ($self,$spec)=@_;my$ag=$self->accessor_generator;my%test;NAME: foreach my$name (sort keys %$spec){my$attr_spec=$spec->{$name};next NAME unless defined($attr_spec->{init_arg})or $ag->has_eager_default($name,$attr_spec);$test{$name}=$attr_spec->{init_arg}}join '',map {my$arg_key=perlstring($test{$_});my$test="exists \$args->{$arg_key}";my$source="\$args->{$arg_key}";my$attr_spec=$spec->{$_};$self->_cap_call($ag->generate_populate_set('$new',$_,$attr_spec,$source,$test,$test{$_},))}sort keys%test}sub _check_required {my ($self,$spec)=@_;my@required_init=map$spec->{$_}{init_arg},grep {my%s=%{$spec->{$_}};$s{required}and not($s{builder}or $s{default})}sort keys %$spec;return '' unless@required_init;'    if (my @missing = grep !exists $args->{$_}, qw(' .join(' ',@required_init).')) {'."\n" .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n" ."    }\n"}use Moo;Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(attribute_specs=>{is=>'ro',reader=>'all_attribute_specs',},accessor_generator=>{is=>'ro' },construction_string=>{is=>'lazy' },subconstructor_handler=>{is=>'ro' },package=>{is=>'ro' },);1;
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;use strictures 1;use base qw(Moo::Object);use Sub::Quote;use Moo::_Utils;use B qw(perlstring);sub generate_method {my ($self,$into)=@_;quote_sub "${into}::DEMOLISHALL",join '',$self->_handle_subdemolish($into),qq{    my \$self = shift;\n},$self->demolishall_body_for($into,'$self','@_'),qq{    return \$self\n};quote_sub "${into}::DESTROY",join '',q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL(Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !}sub demolishall_body_for {my ($self,$into,$me,$args)=@_;my@demolishers=grep *{_getglob($_)}{CODE},map "${_}::DEMOLISH",@{Moo::_Utils::_get_linear_isa($into)};join '',map qq{    ${me}->${_}(${args});\n},@demolishers}sub _handle_subdemolish {my ($self,$into)=@_;'    if (ref($_[0]) ne '.perlstring($into).') {'."\n".'      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".'    }'."\n"}1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;use strictures 1;use Text::Balanced qw(extract_bracketed);use Sub::Quote ();sub slurp {do {local (@ARGV,$/)=$_[0];<>}}sub splat {open my$out,'>',$_[1]or die "can't open $_[1]: $!";print$out $_[0]or die "couldn't write to $_[1]: $!"}sub inlinify {my$file=$_[0];my@chunks=split /(^sub.*?^}$)/sm,slurp$file;warn join "\n--\n",@chunks;my%code;for my$chunk (@chunks){if (my ($name,$body)=$chunk =~ /^sub (\S+) {\n(.*)\n}$/s){$code{$name}=$body}}for my$chunk (@chunks){my ($me)=$chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;my$meq=quotemeta$me;my$copy=$chunk;my ($fixed,$rest);while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s){my ($front,$name)=($1,$2);((my$body),$rest)=extract_bracketed($copy,'()');warn "spotted ${name} - ${body}";if ($code{$name}){warn "replacing";s/^\(//,s/\)$// for$body;$body="${me}, ".$body;$fixed .= $front.Sub::Quote::inlinify($code{$name},$body)}else {$fixed .= $front.$me.'->'.$name.$body}$copy=$rest}$fixed .= $rest if$fixed;warn$fixed if$fixed;$chunk=$fixed if$fixed}print join '',@chunks}1;
METHOD_INLINER

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;use strictures 1;use Moo::_Utils;use B 'perlstring';use Sub::Defer ();our$VERSION='1.003001';$VERSION=eval$VERSION;require Moo::sification;our%MAKERS;sub _install_tracked {my ($target,$name,$code)=@_;$MAKERS{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::${name}"=>$code}sub import {my$target=caller;my$class=shift;strictures->import;if ($Role::Tiny::INFO{$target}and $Role::Tiny::INFO{$target}{is_role}){die "Cannot import Moo into a role"}$MAKERS{$target}||={};_install_tracked$target=>extends=>sub {$class->_set_superclasses($target,@_);$class->_maybe_reset_handlemoose($target);return};_install_tracked$target=>with=>sub {require Moo::Role;Moo::Role->apply_roles_to_package($target,@_);$class->_maybe_reset_handlemoose($target)};_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){require Carp;Carp::croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;$class->_constructor_maker_for($target)->register_attribute_specs($name,$spec_ref);$class->_accessor_maker_for($target)->generate_method($target,$name,$spec_ref);$class->_maybe_reset_handlemoose($target)}return};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {require Class::Method::Modifiers;_install_modifier($target,$type,@_);return}}return if$MAKERS{$target}{is_class};$MAKERS{$target}{is_class}=1;{no strict 'refs';@{"${target}::ISA"}=do {require Moo::Object;('Moo::Object')}unless @{"${target}::ISA"}}if ($INC{'Moo/HandleMoose.pm'}){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub unimport {my$target=caller;_unimport_coderefs($target,$MAKERS{$target})}sub _set_superclasses {my$class=shift;my$target=shift;for my$superclass (@_){_load_module($superclass);if ($INC{"Role/Tiny.pm"}&& $Role::Tiny::INFO{$superclass}){require Carp;Carp::croak("Can't extend role '$superclass'")}}@{*{_getglob("${target}::ISA")}{ARRAY}}=@_;if (my$old=delete$Moo::MAKERS{$target}{constructor}){delete _getstash($target)->{new};Moo->_constructor_maker_for($target)->register_attribute_specs(%{$old->all_attribute_specs})}elsif (!$target->isa('Moo::Object')){Moo->_constructor_maker_for($target)}no warnings 'once';$Moo::HandleMoose::MOUSE{$target}=[grep defined,map Mouse::Util::find_meta($_),@_ ]if Mouse::Util->can('find_meta')}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{"Moo/HandleMoose.pm"}){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _accessor_maker_for {my ($class,$target)=@_;return unless$MAKERS{$target};$MAKERS{$target}{accessor}||=do {my$maker_class=do {if (my$m=do {if (my$defer_target=(Sub::Defer::defer_info($target->can('new'))||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);$MAKERS{$pkg}&& $MAKERS{$pkg}{accessor}}else {undef}}){ref($m)}else {require Method::Generate::Accessor;'Method::Generate::Accessor'}};$maker_class->new}}sub _constructor_maker_for {my ($class,$target,$select_super)=@_;return unless$MAKERS{$target};$MAKERS{$target}{constructor}||=do {require Method::Generate::Constructor;require Sub::Defer;my ($moo_constructor,$con);if ($select_super && $MAKERS{$select_super}){$moo_constructor=1;$con=$MAKERS{$select_super}{constructor}}else {my$t_new=$target->can('new');if ($t_new){if ($t_new==Moo::Object->can('new')){$moo_constructor=1}elsif (my$defer_target=(Sub::Defer::defer_info($t_new)||[])->[0]){my ($pkg)=($defer_target =~ /^(.*)::[^:]+$/);if ($MAKERS{$pkg}){$moo_constructor=1;$con=$MAKERS{$pkg}{constructor}}}}else {$moo_constructor=1}};($con ? ref($con): 'Method::Generate::Constructor')->new(package=>$target,accessor_generator=>$class->_accessor_maker_for($target),construction_string=>($moo_constructor ? ($con ? $con->construction_string : undef): ('$class->'.$target.'::SUPER::new($class->can(q[FOREIGNBUILDARGS]) ? $class->FOREIGNBUILDARGS(@_) : @_)')),subconstructor_handler=>('      if ($Moo::MAKERS{$class}) {'."\n" .'        '.$class.'->_constructor_maker_for($class,'.perlstring($target).');'."\n" .'        return $class->new(@_)'.";\n" .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n" .'        return $meta->new_object($class->BUILDARGS(@_));'."\n" .'      }'."\n"),)->install_delayed ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})}}1;
MOO

$fatpacked{"Moo/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_CONFLICTS';
  package Moo::Conflicts;use strict;use warnings;use Dist::CheckConflicts -dist=>'Moo',-conflicts=>{'HTML::Restrict'=>'2.1.5',},-also=>[qw(Carp Class::Method::Modifiers strictures Module::Runtime Role::Tiny Devel::GlobalDestruction) ],;1;
MOO_CONFLICTS

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;use strictures 1;use Moo::_Utils;use B qw(perlstring);our%TYPE_MAP;our$SETUP_DONE;sub import {return if$SETUP_DONE;inject_all();$SETUP_DONE=1}sub inject_all {require Class::MOP;inject_fake_metaclass_for($_)for grep $_ ne 'Moo::Object',do {no warnings 'once';keys%Moo::MAKERS};inject_fake_metaclass_for($_)for keys%Moo::Role::INFO;require Moose::Meta::Method::Constructor;@Moo::HandleMoose::FakeConstructor::ISA='Moose::Meta::Method::Constructor'}sub maybe_reinject_fake_metaclass_for {my ($name)=@_;our%DID_INJECT;if (delete$DID_INJECT{$name}){unless ($Moo::Role::INFO{$name}){Moo->_constructor_maker_for($name)->install_delayed}inject_fake_metaclass_for($name)}}sub inject_fake_metaclass_for {my ($name)=@_;require Class::MOP;require Moo::HandleMoose::FakeMetaClass;Class::MOP::store_metaclass_by_name($name,bless({name=>$name },'Moo::HandleMoose::FakeMetaClass'));require Moose::Util::TypeConstraints;if ($Moo::Role::INFO{$name}){Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name)}else {Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name)}}{package Moo::HandleMoose::FakeConstructor;sub _uninlined_body {\&Moose::Object::new}}sub inject_real_metaclass_for {my ($name)=@_;our%DID_INJECT;return Class::MOP::get_metaclass_by_name($name)if$DID_INJECT{$name};require Moose;require Moo;require Moo::Role;require Scalar::Util;Class::MOP::remove_metaclass_by_name($name);my ($am_role,$meta,$attr_specs,$attr_order)=do {if (my$info=$Moo::Role::INFO{$name}){my@attr_info=@{$info->{attributes}||[]};(1,Moose::Meta::Role->initialize($name),{@attr_info },[@attr_info[grep!($_ % 2),0..$#attr_info]])}elsif (my$cmaker=Moo->_constructor_maker_for($name)){my$specs=$cmaker->all_attribute_specs;(0,Moose::Meta::Class->initialize($name),$specs,[sort {$specs->{$a}{index}<=> $specs->{$b}{index}}keys %$specs ])}else {(0,Moose::Meta::Class->initialize($name),{},[])}};for my$spec (values %$attr_specs){if (my$inflators=delete$spec->{moosify}){$_->($spec)for @$inflators}}my%methods=%{Role::Tiny->_concrete_methods_of($name)};if (my$info=$Role::Tiny::INFO{$name}){delete$info->{methods}}Sub::Defer::undefer_sub($_)for grep defined,values%methods;my@attrs;{local @{_getstash($name)}{keys%methods};my%seen_name;for my$name (@$attr_order){$seen_name{$name}=1;my%spec=%{$attr_specs->{$name}};my%spec_map=(map {$_->name=>$_->init_arg||$_->name}((grep {$_->has_init_arg}$meta->attribute_metaclass->meta->get_all_attributes),grep {exists($_->{init_arg})? defined($_->init_arg): 1}map {my$meta=Moose::Util::resolve_metatrait_alias('Attribute',$_)->meta;map$meta->get_attribute($_),$meta->get_attribute_list}@{$spec{traits}||[]}));$spec_map{traits}||='traits';$spec{is}='ro' if$spec{is}eq 'lazy' or $spec{is}eq 'rwp';my$coerce=$spec{coerce};if (my$isa=$spec{isa}){my$tc=$spec{isa}=do {if (my$mapped=$TYPE_MAP{$isa}){my$type=$mapped->();Scalar::Util::blessed($type)&& $type->isa("Moose::Meta::TypeConstraint")or die "error inflating attribute '$name' for package '$_[0]': \$TYPE_MAP{$isa} did not return a valid type constraint'";$coerce ? $type->create_child_type(name=>$type->name): $type}else {Moose::Meta::TypeConstraint->new(constraint=>sub {eval {&$isa;1}})}};if ($coerce){$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{coerce}=1}}elsif ($coerce){my$attr=perlstring($name);my$tc=Moose::Meta::TypeConstraint->new(constraint=>sub {die "This is not going to work"},inlined=>sub {'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'},);$tc->coercion(Moose::Meta::TypeCoercion->new)->_compiled_type_coercion($coerce);$spec{isa}=$tc;$spec{coerce}=1}%spec=map {$spec_map{$_}=>$spec{$_}}grep {exists$spec_map{$_}}keys%spec;push@attrs,$meta->add_attribute($name=>%spec)}for my$mouse (do {our%MOUSE;@{$MOUSE{$name}||[]}}){for my$attr ($mouse->get_all_attributes){my%spec=%{$attr};delete@spec{qw(associated_class associated_methods __METACLASS__ provides curries)};my$name=delete$spec{name};next if$seen_name{$name}++;push@attrs,$meta->add_attribute($name=>%spec)}}}for my$meth_name (keys%methods){my$meth_code=$methods{$meth_name};$meta->add_method($meth_name,$meth_code)if$meth_code}if ($am_role){my$info=$Moo::Role::INFO{$name};$meta->add_required_methods(@{$info->{requires}});for my$modifier (@{$info->{modifiers}}){my ($type,@args)=@$modifier;my$code=pop@args;$meta->${\"add_${type}_method_modifier"}($_,$code)for@args}}else {for my$attr (@attrs){for my$method (@{$attr->associated_methods}){$method->{body}=$name->can($method->name)}}bless($meta->find_method_by_name('new'),'Moo::HandleMoose::FakeConstructor',);require Method::Generate::DemolishAll}$meta->add_role(Class::MOP::class_of($_))for grep!/\|/ && $_ ne $name,do {no warnings 'once';keys %{$Role::Tiny::APPLIED_TO{$name}}};$DID_INJECT{$name}=1;$meta}1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;sub DESTROY {}sub AUTOLOAD {my ($meth)=(our$AUTOLOAD =~ /([^:]+)$/);require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->$meth(@_)}sub can {require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->can(@_)}sub isa {require Moo::HandleMoose;Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->isa(@_)}sub make_immutable {$_[0]}1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;use strictures 1;our%NO_BUILD;our%NO_DEMOLISH;our$BUILD_MAKER;our$DEMOLISH_MAKER;sub new {my$class=shift;unless (exists$NO_DEMOLISH{$class}){unless ($NO_DEMOLISH{$class}=!$class->can('DEMOLISH')){($DEMOLISH_MAKER ||=do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method($class)}}$NO_BUILD{$class}and return bless({ref($_[0])eq 'HASH' ? %{$_[0]}: @_},$class);$NO_BUILD{$class}=!$class->can('BUILD')unless exists$NO_BUILD{$class};$NO_BUILD{$class}? bless({ref($_[0])eq 'HASH' ? %{$_[0]}: @_},$class): do {my$proto=ref($_[0])eq 'HASH' ? $_[0]: {@_};bless({%$proto},$class)->BUILDALL($proto)}}sub BUILDARGS {my$class=shift;if (scalar @_==1){unless (defined $_[0]&& ref $_[0]eq 'HASH'){die "Single parameters to new() must be a HASH ref" ." data => ".$_[0]."\n"}return {%{$_[0]}}}elsif (@_ % 2){die "The new() method for $class expects a hash reference or a key/value list." ." You passed an odd number of arguments\n"}else {return {@_}}}sub BUILDALL {my$self=shift;$self->${\(($BUILD_MAKER ||=do {require Method::Generate::BuildAll;Method::Generate::BuildAll->new})->generate_method(ref($self)))}(@_)}sub DEMOLISHALL {my$self=shift;$self->${\(($DEMOLISH_MAKER ||=do {require Method::Generate::DemolishAll;Method::Generate::DemolishAll->new})->generate_method(ref($self)))}(@_)}sub does {require Role::Tiny;{no warnings 'redefine';*does=\&Role::Tiny::does_role}goto&Role::Tiny::does_role}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;use strictures 1;use Moo::_Utils;use Role::Tiny ();use base qw(Role::Tiny);our$VERSION='1.003001';$VERSION=eval$VERSION;require Moo::sification;BEGIN {*INFO=\%Role::Tiny::INFO}our%INFO;our%APPLY_DEFAULTS;sub _install_tracked {my ($target,$name,$code)=@_;$INFO{$target}{exports}{$name}=$code;_install_coderef "${target}::${name}"=>"Moo::Role::${name}"=>$code}sub import {my$target=caller;my ($me)=@_;strictures->import;if ($Moo::MAKERS{$target}and $Moo::MAKERS{$target}{is_class}){die "Cannot import Moo::Role into a Moo class"}$INFO{$target}||={};my$stash=_getstash($target);_install_tracked$target=>has=>sub {my$name_proto=shift;my@name_proto=ref$name_proto eq 'ARRAY' ? @$name_proto : $name_proto;if (@_ % 2!=0){require Carp;Carp::croak("Invalid options for " .join(', ',map "'$_'",@name_proto)." attribute(s): even number of arguments expected, got " .scalar @_)}my%spec=@_;for my$name (@name_proto){my$spec_ref=@name_proto > 1 ? +{%spec}: \%spec;($INFO{$target}{accessor_maker}||=do {require Method::Generate::Accessor;Method::Generate::Accessor->new})->generate_method($target,$name,$spec_ref);push @{$INFO{$target}{attributes}||=[]},$name,$spec_ref;$me->_maybe_reset_handlemoose($target)}};for my$type (qw(before after around)){_install_tracked$target=>$type=>sub {require Class::Method::Modifiers;push @{$INFO{$target}{modifiers}||=[]},[$type=>@_ ];$me->_maybe_reset_handlemoose($target)}}_install_tracked$target=>requires=>sub {push @{$INFO{$target}{requires}||=[]},@_;$me->_maybe_reset_handlemoose($target)};_install_tracked$target=>with=>sub {$me->apply_roles_to_package($target,@_);$me->_maybe_reset_handlemoose($target)};return if$INFO{$target}{is_role};$INFO{$target}{is_role}=1;*{_getglob("${target}::meta")}=$me->can('meta');my@not_methods=('',map {*$_{CODE}||()}grep!ref($_),values %$stash);@{$INFO{$target}{not_methods}={}}{@not_methods}=@not_methods;$Role::Tiny::APPLIED_TO{$target}={$target=>undef };if ($INC{'Moo/HandleMoose.pm'}){Moo::HandleMoose::inject_fake_metaclass_for($target)}}sub meta {require Moo::HandleMoose::FakeMetaClass;my$class=ref($_[0])||$_[0];bless({name=>$class },'Moo::HandleMoose::FakeMetaClass')}sub unimport {my$target=caller;_unimport_coderefs($target,$INFO{$target})}sub _maybe_reset_handlemoose {my ($class,$target)=@_;if ($INC{"Moo/HandleMoose.pm"}){Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target)}}sub _inhale_if_moose {my ($self,$role)=@_;_load_module($role);my$meta;if (!$INFO{$role}and ($INC{"Moose.pm"}and $meta=Class::MOP::class_of($role)and $meta->isa('Moose::Meta::Role'))or (Mouse::Util->can('find_meta')and $meta=Mouse::Util::find_meta($role)and $meta->isa('Mouse::Meta::Role'))){$INFO{$role}{methods}={map +($_=>$role->can($_)),grep!$meta->get_method($_)->isa('Class::MOP::Method::Meta'),$meta->get_method_list };$Role::Tiny::APPLIED_TO{$role}={map +($_->name=>1),$meta->calculate_all_roles };$INFO{$role}{requires}=[$meta->get_required_method_list ];$INFO{$role}{attributes}=[map +($_=>do {my$attr=$meta->get_attribute($_);my$is_mouse=$meta->isa('Mouse::Meta::Role');my$spec={%{$is_mouse ? $attr : $attr->original_options}};if ($spec->{isa}){my$get_constraint=do {my$pkg=$is_mouse ? 'Mouse::Util::TypeConstraints' : 'Moose::Util::TypeConstraints';_load_module($pkg);$pkg->can('find_or_create_isa_type_constraint')};my$tc=$get_constraint->($spec->{isa});my$check=$tc->_compiled_type_constraint;$spec->{isa}=sub {&$check or die "Type constraint failed for $_[0]"};if ($spec->{coerce}){$spec->{coerce}=$tc->${\($tc->can('coercion')||sub {$_[0]})}->_compiled_type_coercion}}$spec}),$meta->get_attribute_list ];my$mods=$INFO{$role}{modifiers}=[];for my$type (qw(before after around)){my$map=$meta->${\($meta->can("get_${type}_method_modifiers_map")or sub {shift->{"${type}_method_modifiers"}})};for my$method (keys %$map){for my$mod (@{$map->{$method}}){push @$mods,[$type=>$method=>$mod ]}}}require Class::Method::Modifiers if @$mods;$INFO{$role}{inhaled_from_moose}=1;$INFO{$role}{is_role}=1}}sub _maybe_make_accessors {my ($self,$target,$role)=@_;my$m;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}or $INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($target)and ref($m)ne 'Method::Generate::Accessor'){$self->_make_accessors($target,$role)}}sub _make_accessors_if_moose {my ($self,$target,$role)=@_;if ($INFO{$role}&& $INFO{$role}{inhaled_from_moose}){$self->_make_accessors($target,$role)}}sub _make_accessors {my ($self,$target,$role)=@_;my$acc_gen=($Moo::MAKERS{$target}{accessor}||=do {require Method::Generate::Accessor;Method::Generate::Accessor->new});my$con_gen=$Moo::MAKERS{$target}{constructor};my@attrs=@{$INFO{$role}{attributes}||[]};while (my ($name,$spec)=splice@attrs,0,2){if ($con_gen){$spec=$con_gen->all_attribute_specs->{$name}}$acc_gen->generate_method($target,$name,$spec)}}sub role_application_steps {qw(_handle_constructor _maybe_make_accessors),$_[0]->SUPER::role_application_steps}sub apply_roles_to_package {my ($me,$to,@roles)=@_;for my$role (@roles){$me->_inhale_if_moose($role);die "${role} is not a Moo::Role" unless$INFO{$role}}$me->SUPER::apply_roles_to_package($to,@roles)}sub apply_single_role_to_package {my ($me,$to,$role)=@_;$me->_inhale_if_moose($role);die "${role} is not a Moo::Role" unless$INFO{$role};$me->SUPER::apply_single_role_to_package($to,$role)}sub create_class_with_roles {my ($me,$superclass,@roles)=@_;my ($new_name,$compose_name)=$me->_composite_name($superclass,@roles);return$new_name if$Role::Tiny::COMPOSED{class}{$new_name};for my$role (@roles){$me->_inhale_if_moose($role)}my$m;if ($INC{"Moo.pm"}and $m=Moo->_accessor_maker_for($superclass)and ref($m)ne 'Method::Generate::Accessor'){*{_getglob("${new_name}::ISA")}=[$superclass ];$me->apply_roles_to_package($new_name,@roles);return$new_name}require Sub::Quote;$me->SUPER::create_class_with_roles($superclass,@roles);for my$role (@roles){die "${role} is not a Role::Tiny" unless$INFO{$role}}$Moo::MAKERS{$new_name}={is_class=>1};$me->_handle_constructor($new_name,$_)for@roles;return$new_name}sub apply_roles_to_object {my ($me,$object,@roles)=@_;my$new=$me->SUPER::apply_roles_to_object($object,@roles);my$apply_defaults=$APPLY_DEFAULTS{ref$new}||=do {my%attrs=map {@{$INFO{$_}{attributes}||[]}}@roles;if ($INC{'Moo.pm'}and keys%attrs and my$con_gen=Moo->_constructor_maker_for(ref$new)and my$m=Moo->_accessor_maker_for(ref$new)){require Sub::Quote;my$specs=$con_gen->all_attribute_specs;my$assign='';my%captures;for my$name (keys%attrs){my$spec=$specs->{$name};if ($m->has_eager_default($name,$spec)){my ($has,$has_cap)=$m->generate_simple_has('$_[0]',$name,$spec);my ($code,$pop_cap)=$m->generate_use_default('$_[0]',$name,$spec,$has);$assign .= $code;@captures{keys %$has_cap,keys %$pop_cap}=(values %$has_cap,values %$pop_cap)}}Sub::Quote::quote_sub($assign,\%captures)}else {sub {}}};$new->$apply_defaults;return$new}sub _composable_package_for {my ($self,$role)=@_;my$composed_name='Role::Tiny::_COMPOSABLE::'.$role;return$composed_name if$Role::Tiny::COMPOSED{role}{$composed_name};$self->_make_accessors_if_moose($composed_name,$role);$self->SUPER::_composable_package_for($role)}sub _install_single_modifier {my ($me,@args)=@_;_install_modifier(@args)}sub _handle_constructor {my ($me,$to,$role)=@_;my$attr_info=$INFO{$role}&& $INFO{$role}{attributes};return unless$attr_info && @$attr_info;if ($INFO{$to}){push @{$INFO{$to}{attributes}||=[]},@$attr_info}else {if ($INC{"Moo.pm"}and my$con=Moo->_constructor_maker_for($to)){$con->register_attribute_specs(map ref()? {%$_}: $_,@$attr_info)}}}1;
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;no warnings 'once';sub _getglob {\*{$_[0]}}sub _getstash {\%{"$_[0]::"}}use constant lt_5_8_3=>($] < 5.008003 or $ENV{MOO_TEST_PRE_583})? 1 : 0;use constant can_haz_subname=>eval {require Sub::Name};use strictures 1;use Module::Runtime qw(require_module);use Devel::GlobalDestruction ();use base qw(Exporter);use Moo::_mro;our@EXPORT=qw(_getglob _install_modifier _load_module _maybe_load_module _get_linear_isa _getstash _install_coderef _name_coderef _unimport_coderefs _in_global_destruction);sub _in_global_destruction ();*_in_global_destruction=\&Devel::GlobalDestruction::in_global_destruction;sub _install_modifier {my ($into,$type,$name,$code)=@_;if (my$to_modify=$into->can($name)){require Sub::Defer;Sub::Defer::undefer_sub($to_modify)}Class::Method::Modifiers::install_modifier(@_)}our%MAYBE_LOADED;sub _load_module {(my$proto=$_[0])=~ s/::/\//g;return 1 if$INC{"${proto}.pm"};my$stash=_getstash($_[0])||{};return 1 if grep +(!ref($_)and *$_{CODE}),values %$stash;require_module($_[0]);return 1}sub _maybe_load_module {return$MAYBE_LOADED{$_[0]}if exists$MAYBE_LOADED{$_[0]};(my$proto=$_[0])=~ s/::/\//g;local $@;if (eval {require "${proto}.pm";1}){$MAYBE_LOADED{$_[0]}=1}else {if (exists$INC{"${proto}.pm"}){warn "$_[0] exists but failed to load with error: $@"}$MAYBE_LOADED{$_[0]}=0}return$MAYBE_LOADED{$_[0]}}sub _get_linear_isa {return mro::get_linear_isa($_[0])}sub _install_coderef {no warnings 'redefine';*{_getglob($_[0])}=_name_coderef(@_)}sub _name_coderef {shift if @_ > 2;can_haz_subname ? Sub::Name::subname(@_): $_[1]}sub _unimport_coderefs {my ($target,$info)=@_;return unless$info and my$exports=$info->{exports};my%rev=reverse %$exports;my$stash=_getstash($target);for my$name (keys %$exports){if ($stash->{$name}and defined(&{$stash->{$name}})){if ($rev{$target->can($name)}){my$old=delete$stash->{$name};my$full_name=join('::',$target,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});no strict 'refs';*$full_name=*{$old}{$type}}}}}}sub STANDARD_DESTROY {my$self=shift;my$e=do {local $?;local $@;eval {$self->DEMOLISHALL(_in_global_destruction)};$@};no warnings 'misc';die$e if$e}1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;if ($] >= 5.010){require mro}else {require MRO::Compat}1;
MOO__MRO

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;use strictures 1;use Moo::_Utils ();sub unimport {our$disarmed=1}sub Moo::HandleMoose::AuthorityHack::DESTROY {unless (our$disarmed or Moo::_Utils::_in_global_destruction){require Moo::HandleMoose;Moo::HandleMoose->import}}if ($INC{"Moose.pm"}){require Moo::HandleMoose;Moo::HandleMoose->import}else {$Moose::AUTHORITY=bless({},'Moo::HandleMoose::AuthorityHack')}1;
MOO_SIFICATION

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;use strictures 1;use base qw(Exporter);use Moo::_Utils;use Scalar::Util qw(weaken);our$VERSION='1.003001';$VERSION=eval$VERSION;our@EXPORT=qw(defer_sub undefer_sub);our%DEFERRED;sub undefer_sub {my ($deferred)=@_;my ($target,$maker,$undeferred_ref)=@{$DEFERRED{$deferred}||return$deferred};return ${$undeferred_ref}if ${$undeferred_ref};${$undeferred_ref}=my$made=$maker->();if (defined($target)&& $deferred eq *{_getglob($target)}{CODE}||''){no warnings 'redefine';*{_getglob($target)}=$made}weaken($DEFERRED{$made}=$DEFERRED{$deferred});return$made}sub defer_info {my ($deferred)=@_;$DEFERRED{$deferred||''}}sub defer_sub {my ($target,$maker)=@_;my$undeferred;my$deferred_info;my$deferred=sub {$undeferred ||=undefer_sub($deferred_info->[3]);goto &$undeferred};$deferred_info=[$target,$maker,\$undeferred,$deferred ];weaken($DEFERRED{$deferred}=$deferred_info);_install_coderef($target=>$deferred)if defined$target;return$deferred}sub CLONE {%DEFERRED=map {defined $_ ? ($_->[3]=>$_): ()}values%DEFERRED;weaken($_)for values%DEFERRED}1;
SUB_DEFER

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;use strictures 1;sub _clean_eval {eval $_[0]}use Sub::Defer;use B 'perlstring';use Scalar::Util qw(weaken);use base qw(Exporter);our$VERSION='1.003001';$VERSION=eval$VERSION;our@EXPORT=qw(quote_sub unquote_sub quoted_from_sub);our%QUOTED;our%WEAK_REFS;sub capture_unroll {my ($from,$captures,$indent)=@_;join('',map {/^([\@\%\$])/ or die "capture key should start with \@, \% or \$: $_";(' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n}}keys %$captures)}sub inlinify {my ($code,$args,$extra,$local)=@_;my$do='do { '.($extra||'');if (my ($code_args,$body)=$code =~ / +my \(([^)]+)\) = \@_;(.*)$/s){if ($code_args eq $args){$do.$body.' }'}else {$do.'my ('.$code_args.') = ('.$args.'); '.$body.' }'}}else {my$assign='';if ($local || $args ne '@_'){$assign=($local ? 'local ' : '').'@_ = ('.$args.'); '}$do.$assign.$code.' }'}}sub quote_sub {my$options=(ref($_[-1])eq 'HASH' and ref($_[-2])eq 'HASH')? pop : {};my$captures=pop if ref($_[-1])eq 'HASH';undef($captures)if$captures &&!keys %$captures;my$code=pop;my$name=$_[0];my$quoted_info;my$deferred=defer_sub +($options->{no_install}? undef : $name)=>sub {unquote_sub($quoted_info->[4])};$quoted_info=[$name,$code,$captures,undef,$deferred ];weaken($QUOTED{$deferred}=$quoted_info);return$deferred}sub quoted_from_sub {my ($sub)=@_;$QUOTED{$sub||''}}sub unquote_sub {my ($sub)=@_;unless ($QUOTED{$sub}[3]){my ($name,$code,$captures)=@{$QUOTED{$sub}};my$make_sub="{\n";my%captures=$captures ? %$captures : ();$captures{'$_QUOTED'}=\$QUOTED{$sub};$make_sub .= capture_unroll("\$_[1]",\%captures,2);$make_sub .= ($name ? "  no warnings 'closure';\n  sub ${name} {\n" : "  \$_QUOTED->[3] = sub {\n");$make_sub .= $code;$make_sub .= "  }".($name ? '' : ';')."\n";if ($name){$make_sub .= "  \$_QUOTED->[3] = \\&${name}\n"}$make_sub .= "}\n1;\n";$ENV{SUB_QUOTE_DEBUG}&& warn$make_sub;{local $@;no strict 'refs';local *{$name}if$name;unless (_clean_eval$make_sub,\%captures){die "Eval went very, very wrong:\n\n${make_sub}\n\n$@"}}}$QUOTED{$sub}[3]}sub CLONE {%QUOTED=map {defined $_ ? ($_->[4]=>$_): ()}values%QUOTED;weaken($_)for values%QUOTED}1;
SUB_QUOTE

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;use strictures 1;use Moo::_Utils;sub moo {print <<'EOMOO';exit 0}BEGIN {my$package;sub import {moo()if $0 eq '-';$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;_load_module($package)}}use Filter::Simple sub {s/^/package $package;\nuse Moo;\n/}}1;
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
OO

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;use strict;use warnings FATAL=>'all';BEGIN {*_PERL_LT_5_8_4=($] < 5.008004)? sub(){1}: sub(){0}}our$VERSION='1.005001';sub VERSION {for ($_[1]){last unless defined &&!ref && int!=1;die "Major version specified as $_ - this is strictures version 1"}no warnings 'uninitialized';shift->SUPER::VERSION(@_)}our$extra_load_states;our$Smells_Like_VCS=(-e '.git' || -e '.svn' || -e '.hg' || (-e '../../dist.ini' && (-e '../../.git' || -e '../../.svn' || -e '../../.hg')));sub import {strict->import;warnings->import(FATAL=>'all');my$extra_tests=do {if (exists$ENV{PERL_STRICTURES_EXTRA}){if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}){die 'PERL_STRICTURES_EXTRA checks are not available on perls older than 5.8.4: ' ."please unset \$ENV{PERL_STRICTURES_EXTRA}\n"}$ENV{PERL_STRICTURES_EXTRA}}elsif (!_PERL_LT_5_8_4){!!((caller)[1]=~ /^(?:t|xt|lib|blib)/ and $Smells_Like_VCS)}};if ($extra_tests){$extra_load_states ||=do {my (%rv,@failed);for my$mod (qw(indirect multidimensional bareword::filehandles)){eval "require $mod; \$rv{'$mod'} = 1;" or do {push@failed,$mod;(my$file=$mod)=~ s|::|/|g;delete$INC{"${file}.pm"}}}if (@failed){my$failed=join ' ',@failed;print STDERR <<EOE}\%rv};indirect->unimport(':fatal')if$extra_load_states->{indirect};multidimensional->unimport if$extra_load_states->{multidimensional};bareword::filehandles->unimport if$extra_load_states->{'bareword::filehandles'}}}1;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  EOE
STRICTURES

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE



use strict;
use warnings;
$|++;

use App::Task::Base;
use App::Task::Command::Start;
use App::Task::Command::Ready;
use App::Task::Command::Deploy;
use App::Task::Command::Status;
use App::Task::Command::Cleanup;

my $task = App::Task::Base->new;
$task->run;
